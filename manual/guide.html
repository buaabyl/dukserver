<!DOCTYPE html>
<html class="wf-nojavascript">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="favicon.ico" rel="icon" type="image/x-icon"/>
<link href="touch_icon_152x152.png" rel="apple-touch-icon" sizes="152x152"/>
<link href="touch_icon_144x144.png" rel="apple-touch-icon" sizes="144x144"/>
<link href="touch_icon_120x120.png" rel="apple-touch-icon" sizes="120x120"/>
<link href="touch_icon_114x114.png" rel="apple-touch-icon" sizes="114x114"/>
<link href="touch_icon_72x72.png" rel="apple-touch-icon" sizes="72x72"/>
<link href="touch_icon_60x60.png" rel="apple-touch-icon" sizes="60x60"/>
<link href="touch_icon_57x57.png" rel="apple-touch-icon" sizes="57x57"/>
<link href="touch_icon_57x57.png" rel="apple-touch-icon"/>
<link href="startup_image_320x480.png" rel="apple-touch-startup-image"/>

<!-- combined stylesheet -->
<link href="style.css" rel="stylesheet" type="text/css"/>
<title>Duktape Programmer's Guide</title>
</head>
<body>
<div id="site-top">
<div id="site-top-logo">
<strong id="logo">((o) Duktape</strong>
</div> <!-- site-top-logo -->
<div id="site-top-nav">
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="api.html">API</a></li>
<li class="selected"><a href="guide.html">Guide</a></li>
<li><a href="dukweb.html">REPL</a></li>
</ul>
</div> <!-- site-top-nav -->
</div> <!-- site-top -->
<div id="site-dummy-github" style="position:relative">
<a href="https://github.com/svaarala/duktape"><img alt="Fork me on GitHub" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" style="position: absolute; top: 0; right: 0; border: 0;"/></a>
</div>
<div id="site-middle">
<div id="site-middle-nav"><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#gettingstarted">Getting started</a></li>
<li><a href="#programming">Programming model</a></li>
<li><a href="#stacktypes">Stack types</a></li>
<li><a href="#ctypes">C types</a></li>
<li><a href="#typealgorithms">Type algorithms</a></li>
<li><a href="#duktapebuiltins">Duktape built-ins</a></li>
<li><a href="#es6features">Ecmascript E6 features</a></li>
<li><a href="#custombehavior">Custom behavior</a></li>
<li><a href="#customjson">Custom JSON formats</a></li>
<li><a href="#customdirectives">Custom directives</a></li>
<li><a href="#errorobjects">Error objects</a></li>
<li><a href="#functionobjects">Function objects</a></li>
<li><a href="#debugger">Debugger</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#finalization">Finalization</a></li>
<li><a href="#coroutines">Coroutines</a></li>
<li><a href="#virtualproperties">Virtual properties</a></li>
<li><a href="#internalproperties">Internal properties</a></li>
<li><a href="#threading">Threading</a></li>
<li><a href="#sandboxing">Sandboxing</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#memoryusage">Memory usage</a></li>
<li><a href="#compiling">Compiling</a></li>
<li><a href="#portability">Portability</a></li>
<li><a href="#compatibility">Compatibility</a></li>
<li><a href="#versioning">Versioning</a></li>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#comparisontolua">Comparison to Lua</a></li>
</ul></div> <!-- site-middle-nav -->
<div class="content" id="site-middle-content"><div class="main-title"><strong>Duktape Programmer's Guide</strong></div><hr/><h1 class="sectiontitle" id="introduction">Introduction <a class="sectionlink" href="#introduction">§</a></h1><p>Version: 1.2.0 (2015-04-05)</p><h2 class="sectiontitle" id="introduction.1">Document scope <a class="sectionlink" href="#introduction.1">§</a></h2><p>This guide provides an introduction to using Duktape in your programs.
Once you're familiar with the basics, there is a concise
<a href="api.html">API reference</a> for looking up API details.</p><p>This document doesn't cover Duktape internals (see the
<a href="https://github.com/svaarala/duktape/tree/master/doc">Duktape repo</a>
if you wish to tinker with them).</p><h2 class="sectiontitle" id="introduction.2">What is Duktape? <a class="sectionlink" href="#introduction.2">§</a></h2><p>Duktape is an embeddable Ecmascript E5/E5.1 engine with a focus
on portability and compact footprint.  By integrating Duktape into your
C/C++ program you can easily extend its functionality through scripting.
You can also build the main control flow of your program in Ecmascript
and use fast C code functions to do heavy lifting.</p><p>The terms Ecmascript and Javascript are often considered more or less
equivalent, although Javascript and its variants are technically just one
environment where the Ecmascript language is used.  The line between the
two is not very clear in practice: even non-browser Ecmascript environments
often provide some browser-specific built-ins.  Duktape is no exception,
and provides the commonly used <code>print()</code> and <code>alert()</code>
built-ins.  Even so, we use the term Ecmascript throughout to refer to the
language implemented by Duktape.</p><h2 class="sectiontitle" id="introduction.3">Conformance <a class="sectionlink" href="#introduction.3">§</a></h2><p>Duktape conforms to the following Ecmascript specifications:</p><ul>
<li><a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf">Edition 5 (E5)</a></li>
<li><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Edition 5.1 (E5.1)</a>
    (as <a href="http://www.ecma-international.org/ecma-262/5.1/">HTML</a>)</li>
</ul><p>The upcoming Ecmascript Edition 6 standard is not yet final.  Duktape borrows
<a href="#es6features">a few features</a> from the E6 draft:</p><ul>
<li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html">Edition 6 (E6) draft</a> (Rev 24, April 27, 2014)</li>
</ul><p>See also:</p><ul>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">Draft Specification for ES.next (Ecma-262 Edition 6)</a></li>
</ul><h2 class="sectiontitle" id="introduction.4">Features <a class="sectionlink" href="#introduction.4">§</a></h2><p>Besides standard Ecmascript features, Duktape has the following additional
features (some are visible to applications, while others are internal):</p><ul>
<li>Borrowed from ES6: <code>setPrototypeOf</code>/<code>__proto__</code>
    and a subset of <code>Proxy</code> objects</li>
<li>Borrowed from browsers: <code>print()</code> and <code>alert()</code></li>
<li>Duktape specific built-ins: provided by the <code>Duktape</code> global object</li>
<li>Extended types: custom "buffer" and "pointer" types, extended string type
    which supports arbitary binary strings and
    non-<a href="http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a>
    strings (standard Ecmascript only supports 16-bit codepoints)</li>
<li>Combined reference counting and mark-and-sweep garbage collection,
    with finalizers and emergency garbage collection (you can also build
    with just reference counting or mark-and-sweep)</li>
<li>Coroutine support</li>
<li>Tail call support</li>
<li>Built-in debugger</li>
<li>Built-in CommonJS-based module loading framework</li>
<li>Built-in regular expression engine with no platform dependencies</li>
<li>Built-in Unicode support with no platform dependencies</li>
<li>Built-in number parsing and formatting with no platform dependencies</li>
<li>Additional custom JSON formats (JX and JC)</li>
<li>Very lightweight built-in logging framework available for both C and
    Ecmascript code</li>
</ul><h2 class="sectiontitle" id="introduction.5">Goals <a class="sectionlink" href="#introduction.5">§</a></h2><p><b>Compliance</b>.  Ecmascript E5/E5.1 and real world compliance.
Ecmascript compliance requires regular expression and Unicode support.
When possible, implement features from the upcoming Ecmascript E6
specification to minimize Duktape custom features.</p><p><b>Portability</b>.  Minimal system dependencies are nice when porting,
so Duktape depends on very few system libraries.  For example, number
formatting and parsing, regular expressions, and Unicode are all implemented
internally by Duktape.  One of the few dependencies that cannot be fully
eliminated is system date/time integration.  This is confined to the
implementation of the <code>Date</code> built-in.</p><p><b>Easy C interface</b>.  The interface between Duktape and C programs
should be natural and error-tolerant.  As a particular issue, string
representation should be UTF-8 with automatic NUL terminators to match
common C use.</p><p><b>Small footprint</b>.  Code and data footprint should be as small as
possible, even for small programs.  This is more important than performance,
as there are already several very fast engines but fewer very compact,
portable engines.</p><p><b>Reasonable performance</b>.  Small footprint (and portability, to some
extent) probably eliminates the possibility of a competitive JIT-based engine,
so there is no practical way of competing with very advanced JIT-based engines
like SpiderMonkey (and its optimized variants) or Google V8.  Performance
should still be reasonable for typical embedded programs.
<a href="http://www.lua.org/">Lua</a> is a good benchmark in this respect.
(Adding optional, modular support for JITing or perhaps off-line compilation
would be nice.)</p><p><b>ASCII string performance</b>.  It's important that operations dealing
with plain ASCII strings be very fast: ASCII dominates most embedded use.
Operations dealing with non-ASCII strings need to perform reasonably but are
not critical.  This is a necessary trade-off: using C-compatible strings means
essentially using UTF-8 string representation which makes string indexing and
many other operations slower than with fixed size character representations.
It's still important to support common idioms like iterating strings sequentially
(in either direction) efficiently.</p><h2 class="sectiontitle" id="introduction.6">Document organization <a class="sectionlink" href="#introduction.6">§</a></h2><p><a href="#gettingstarted">Getting started</a> guides you through downloading,
compiling, and integrating Duktape into your program.  It also provides concrete
examples of how you can integrate scripting capabilities into your program.</p><p><a href="#programming">Programming model</a>, <a href="#stacktypes">Stack types</a>,
and <a href="#ctypes">C types</a>
discuss core Duktape concepts such as <i>heap</i>, <i>context</i>, <i>value stacks</i>,
<i>Duktape API</i>, and <i>Duktape/C functions</i>.  Duktape stack types and C type
wrappers are discussed in detail.</p><p>Duktape specific Ecmascript features are discussed in multiple sections:
<a href="#typealgorithms">Type algorithms</a> (for custom types),
<a href="#duktapebuiltins">Duktape built-ins</a> (additional built-ins), 
<a href="#es6features">Ecmascript E6 features</a> (features borrowed from ES6),
<a href="#custombehavior">Custom behavior</a> (behavior differing from standard),
<a href="#customjson">Custom JSON formats</a>,
<a href="#customdirectives">Custom directives</a>,
<a href="#errorobjects">Error objects</a> (properties and traceback support),
<a href="#functionobjects">Function objects</a> (properties),
<a href="#debugger">Debugger</a>,
<a href="#modules">Modules</a>,
<a href="#logging">Logging</a>,
<a href="#finalization">Finalization</a>,
<a href="#coroutines">Coroutines</a>,
<a href="#virtualproperties">Virtual properties</a>,
<a href="#internalproperties">Internal properties</a>,
<a href="#threading">Threading</a>,
<a href="#sandboxing">Sandboxing</a>.
</p><p><a href="#performance">Performance</a> provides a few Duktape-specific tips
for improving performance and avoiding performance pitfalls.
<a href="#memoryusage">Memory usage</a> summarizes Duktape memory usage and
gives pointers for minimizing it.
<a href="#compiling">Compiling</a> describes how to compile Duktape in detail,
covering in particular available feature defines.
<a href="#portability">Portability</a> covers platform and compiler specific
issues and other portability issues.
<a href="#compatibility">Compatibility</a> discusses Duktape's compatibility
with Ecmascript dialects, extensions, and frameworks.
<a href="#versioning">Versioning</a> describes Duktape versioning and what version
compatibility to expect.
<a href="#limitations">Limitations</a> summarizes currently known limitations
and provides possible workarounds.</p><p><a href="#comparisontolua">Comparison to Lua</a> discusses some differences
between Lua and Duktape; it may be useful reading if you're already familiar with Lua.</p><hr/><h1 class="sectiontitle" id="gettingstarted">Getting started <a class="sectionlink" href="#gettingstarted">§</a></h1><h2 class="sectiontitle" id="gettingstarted.1">Downloading <a class="sectionlink" href="#gettingstarted.1">§</a></h2><p>Download the source distributable from the
<a href="download.html">Download</a> page.</p><h2 class="sectiontitle" id="gettingstarted.2">Command line tool <a class="sectionlink" href="#gettingstarted.2">§</a></h2><p>Unpack the distributable:</p><pre>
$ cd /tmp
$ tar xvfJ duktape-&lt;version&gt;.tar.xz
</pre><p>Compile the command line tool using the provided Makefile:</p><pre>
$ cd /tmp/duktape-&lt;version&gt;/
$ make -f Makefile.cmdline
</pre><div class="note">
The Makefile assumes you have <code>gcc</code> installed.  If you don't,
you can just edit the Makefile to match your compiler (the Makefile is
quite simple).
</div><div class="note">
The command line tool avoids platform dependencies by default.  If you're running a
UNIX variant and have <code>readline</code> and the necessary development headers,
you can enable line editing support by editing the Makefile:
<ul>
<li>Add <code class="nobreak">-DDUK_CMDLINE_FANCY</code></li>
<li>Add <code>-lreadline</code> and <code>-lncurses</code></li>
</ul>
</div><p>You can now run Ecmascript code interactively:</p><pre>
$ ./duk
((o) Duktape [no readline] 1.2.0 (v1.2.0)
duk&gt; print('Hello world!')
Hello world!
= undefined
</pre><p>You can also run Ecmascript code from a file which is useful for playing with
features and algorithms.  As an example, create <code>fib.js</code>:</p><pre class="ecmascript-code"><span class="comment">// fib.js</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">fib</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">fib</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="function">fib</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-</span><span class="number">2</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">test</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> res </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">20</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        res</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">fib</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">res</span><span class="symbol">.</span><span class="function">join</span><span class="symbol">(</span><span class="string">' '</span><span class="symbol">));</span>
<span class="cbracket">}</span>

<span class="function">test</span><span class="symbol">();</span>
</pre><p>Test the script from the command line:</p><pre>
$ ./duk fib.js
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
</pre><h2 class="sectiontitle" id="gettingstarted.3">Integrating Duktape into your program <a class="sectionlink" href="#gettingstarted.3">§</a></h2><p>The command line tool is simply an example of a program which embeds
Duktape.  Embedding Duktape into your program is very simple: just add
<code>duktape.c</code> and <code>duktape.h</code> to your build, and call the
Duktape API from elsewhere in your program.</p><p>The distributable contains a very simple example program, <code>hello.c</code>,
which illustrates this process.  Compile the test program e.g. as (see
<a href="#compiling">Compiling</a> for compiler option suggestions):</p><pre>
$ cd /tmp/duktape-&lt;version&gt;/
$ gcc -std=c99 -o hello -Isrc/ src/duktape.c examples/hello/hello.c -lm
</pre><p>The test program creates a Duktape context and uses it to run some
Ecmascript code:</p><pre>
$ ./hello
Hello world!
2+3=5
</pre><p>Because Duktape is an embeddable engine, you don't need to change
the basic control flow of your program.  The basic approach is:</p><ul>
<li>Create a Duktape context e.g. in program initialization
    (or even on-demand when scripting is needed).  Usually you
    would also load your scripts during initialization, though
    that can also be done on-demand.</li>
<li>Identify points in your code where you would like to use scripting
    and insert calls to script functions there.</li>
<li>To make a script function call, first push call arguments to the
    Duktape context's <i>value stack</i> using the Duktape API.
    Then, use another Duktape API call to initiate the actual call.</li>
<li>Once script execution is finished, control is returned to your
    program (the API call returns) and a return value is left on the
    Duktape context's value stack.  C code can then access the return
    value using the Duktape API.</li>
</ul><p>Let's look at a simple example program.  The program reads in a line from
<code>stdin</code> using a C mainloop, calls an Ecmascript helper to transform
the line, and prints out the result.  The line processing function can take
advantage of Ecmascript goodies like regular expressions, and can be easily
modified without recompiling the C program.</p><p>The script code will be placed in <code>process.js</code>.  The example
line processing function converts a plain text line into HTML, and
automatically bolds text between stars:</p><pre class="ecmascript-code"><span class="comment">// process.js</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">processLine</span><span class="symbol">(</span><span class="normal">line</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> line</span><span class="symbol">.</span><span class="function">trim</span><span class="symbol">()</span>
<span class="normal">        </span><span class="symbol">.</span><span class="function">replace</span><span class="symbol">(</span><span class="regexp">/[&lt;&gt;&amp;"'\u0000-\u001F\u007E-\uFFFF]/g</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// escape HTML characters</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="string">'&amp;#'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> x</span><span class="symbol">.</span><span class="function">charCodeAt</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="string">';'</span>
<span class="normal">         </span><span class="cbracket">}</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">.</span><span class="function">replace</span><span class="symbol">(</span><span class="regexp">/\*(.*?)\*/g</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// automatically bold text between stars</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="string">'&lt;b&gt;'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> m </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'&lt;/b&gt;'</span><span class="symbol">;</span>
<span class="normal">         </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>The C code, <code>processlines.c</code> initializes a Duktape context,
evaluates the script, then proceeds to process lines from <code>stdin</code>,
calling <code>processLine()</code> for every line:</p><pre class="c-code"><span class="comment">/* processlines.c */</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdio.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdlib.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;string.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"duktape.h"</span>

<span class="type">int</span><span class="normal"> </span><span class="function">main</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> argc</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">argv</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">    </span><span class="type">char</span><span class="normal"> line</span><span class="symbol">[</span><span class="number">4096</span><span class="symbol">];</span>
<span class="normal">    </span><span class="type">char</span><span class="normal"> idx</span><span class="symbol">;</span>
<span class="normal">    </span><span class="type">int</span><span class="normal"> ch</span><span class="symbol">;</span>

<span class="normal">    ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Failed to create a Duktape heap.</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_peval_file</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"process.js"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> finished</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* ignore result */</span>

<span class="normal">    </span><span class="function">memset</span><span class="symbol">(</span><span class="normal">line</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">line</span><span class="symbol">));</span>
<span class="normal">    idx </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">idx </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">line</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Line too long</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        ch </span><span class="symbol">=</span><span class="normal"> </span><span class="function">fgetc</span><span class="symbol">(</span><span class="normal">stdin</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ch </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0x0a</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            line</span><span class="symbol">[</span><span class="normal">idx</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'</span><span class="specialchar">\0</span><span class="string">'</span><span class="symbol">;</span>

<span class="normal">            </span><span class="function">duk_push_global_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"processLine"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> line</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_pcall</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"%s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* pop result/error */</span>

<span class="normal">            idx </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ch </span><span class="symbol">==</span><span class="normal"> EOF</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            line</span><span class="symbol">[</span><span class="normal">idx</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">)</span><span class="normal"> ch</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="label"> finished:</span>
<span class="normal">    </span><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>

<span class="normal">    </span><span class="function">exit</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>Let's look at the Duktape specific parts of the example code piece by piece.
Here we need to gloss over some details for brevity, see
<a href="#programming">Programming model</a> for a detailed discussion:</p><ul class="breakdown"> <!-- breakdown -->
<li>
<pre class="c-code"><span class="normal">ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">();</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Failed to create a Duktape heap.</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre>
<p>First we create a Duktape context.  A context allows us to exchange values
with Ecmascript code by pushing and popping values to the <b>value stack</b>.
Most calls in the Duktape API operate with the value stack, pushing, popping,
and examining values on the stack.  For production code you should use
<a href="api.html#duk_create_heap">duk_create_heap()</a> so that you can set
a <b>fatal error handler</b>.  See <a href="#error-handling">Error handling</a>
for discussion of error handling best practices.</p>
</li>
<li>
<pre class="c-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_peval_file</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"process.js"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">goto</span><span class="normal"> finished</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* ignore result */</span>
</pre>
<p>The eval call reads in <code>process.js</code>, then compiles and executes
the script.  The script registers <code>processLine()</code> into the Ecmascript
global object for later use.  The eval call is protected so that any script
errors, such as syntax errors, are caught and handled without causing a fatal
error.  If an error occurs, the error message is coerced safely using
<a href="api.html#duk_safe_to_string">duk_safe_to_string()</a> which is
guaranteed not to throw a further error.  The result of the string coercion is
a <code>const char *</code> pointing to a read-only, NUL-terminated, UTF-8
encoded string, which can be used directly with <code>printf</code>.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_push_global_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"processLine"</span><span class="symbol">);</span>
</pre>
<p>The first call pushes the Ecmascript global object to the value stack.
The second call looks up <code>processLine</code> property of the global object
(which the script in <code>process.js</code> has defined).  The <code>-1</code>
argument is an index to the value stack; negative values refer to stack
elements starting from the top, so <code>-1</code> refers to the topmost
element of the stack, the global object.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> line</span><span class="symbol">);</span>
</pre>
<p>Pushes the string pointed to by <code>line</code> to the value stack.  The
string length is automatically determined by scanning for a NUL terminator
(same as <code>strlen()</code>).  Duktape makes a copy of the string when it is
pushed to the stack, so the <code>line</code> buffer can be freely modified when
the call returns.</p>
</li>
<li>
<pre class="c-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_pcall</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"%s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="cbracket">}</span>
<span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* pop result/error */</span>
</pre>
<p>At this point the value stack contains: the global object, the processLine
function, and the <code>line</code> string.  The
<a href="api.html#duk_pcall">duk_pcall()</a> method calls a function with a
specified number of arguments given on the value stack, and replaces both the
function and the argument values with the function's return value.
Here the resulting value stack contains: the global object and the call result.
The call is protected so that errors can be caught and printed.  The
<a href="api.html#duk_safe_to_string">duk_safe_to_string()</a> API call is
again used to print errors safely.  Finally, the result (or error) is popped
off the value stack.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
</pre>
<p>Destroy the Duktape context, freeing all resources held by the context.
This call will free the value stack and all references on the value stack.
In our example we left the global object on the value stack on purpose.
This is not a problem: no memory leaks will occur even if the value stack
is not empty when the heap is destroyed.</p>
</li>
</ul><!-- breakdown --><p>Compile like above:</p><pre>
$ gcc -std=c99 -o processlines -Isrc/ src/duktape.c processlines.c -lm
</pre><p>Test run (ensure that <code>process.js</code> is in the current directory):</p><pre>
$ echo "I like *Sam &amp; Max*." | ./processlines
I like &lt;b&gt;Sam &amp;<!-- avoiding double decode is tricky -->#38; Max&lt;/b&gt;.
</pre><h2 class="sectiontitle" id="gettingstarted.4">Calling C code from Ecmascript (Duktape/C bindings) <a class="sectionlink" href="#gettingstarted.4">§</a></h2><p>The integration example illustrated how C code can call into Ecmascript
to do things which are easy in Ecmascript but difficult in C.</p><p>Ecmascript also often needs to call into C when the situation is
reversed.  For instance, while scripting is useful for many things, it is
not optimal for low level byte or character processing.  Being able to
call optimized C helpers allows you to write most of your script logic in
nice Ecmascript but call into C for the performance critical parts.
Another reason for using native functions is to provide access to native
libraries.</p><p>To implement a native function you write an ordinary C function which
conforms to a special calling convention, the Duktape/C binding.  Duktape/C
functions take a single argument, a Duktape context, and return a single
value indicating either error or number of return values.  The function
accesses call arguments and places return values through the Duktape context's
<i>value stack</i>, manipulated with the Duktape API.  We'll go deeper into
Duktape/C binding and the Duktape API later on.  Example:</p><pre class="c-code"><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_native_func</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">double</span><span class="normal"> arg </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_number</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_push_number</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> arg </span><span class="symbol">*</span><span class="normal"> arg</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>Let's look at this example line by line:</p><ul class="breakdown"> <!-- breakdown -->
<li>
<pre class="c-code"><span class="type">double</span><span class="normal"> arg </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_number</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">);</span>
</pre>
<p>Check that the number at value stack index 0 (bottom of the stack, first
argument to function call) is a number; if not, throws an error and never
returns.  If the value is a number, return it as a <code>double</code>.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_push_number</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> arg </span><span class="symbol">*</span><span class="normal"> arg</span><span class="symbol">);</span>
</pre>
<p>Compute square of argument and push it to the value stack.</p>
</li>
<li>
<pre class="c-code"><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
</pre>
<p>Return from the function call, indicating that there is a (single) return
value on top of the value stack.  You could also return <code>0</code> to indicate
that no return value is given (in which case Duktape defaults to Ecmascript
<code>undefined</code>).  A negative return value which causes an error to be
automatically thrown: this is a shorthand for throwing errors conveniently.
Note that you don't need to pop any values off the stack, Duktape will do that
for you automatically when the function returns.
See <a href="#programming">Programming model</a> for more details.</p>
</li>
</ul><!-- breakdown --><p>We'll use a primality test as an example for using native code to speed
up Ecmascript algorithms.  More specifically, our test program searches for
primes under 1000000 which end with the digits '9999'.  The Ecmascript
version of the program is:</p><pre class="ecmascript-code"><span class="comment">// prime.js</span>

<span class="comment">// Pure Ecmascript version of low level helper</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">primeCheckEcmascript</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">,</span><span class="normal"> limit</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;=</span><span class="normal"> limit</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">val </span><span class="symbol">%</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">// Select available helper at load time</span>
<span class="keyword">var</span><span class="normal"> primeCheckHelper </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">primeCheckNative </span><span class="symbol">||</span><span class="normal"> primeCheckEcmascript</span><span class="symbol">);</span>

<span class="comment">// Check 'val' for primality</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">primeCheck</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">val </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> val </span><span class="symbol">==</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> limit </span><span class="symbol">=</span><span class="normal"> Math</span><span class="symbol">.</span><span class="function">ceil</span><span class="symbol">(</span><span class="normal">Math</span><span class="symbol">.</span><span class="function">sqrt</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">limit </span><span class="symbol">*</span><span class="normal"> limit </span><span class="symbol">&lt;</span><span class="normal"> val</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> limit </span><span class="symbol">+=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">primeCheckHelper</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">,</span><span class="normal"> limit</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">// Find primes below one million ending in '9999'.</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">primeTest</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> res </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Have native helper: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">primeCheckHelper </span><span class="symbol">!==</span><span class="normal"> primeCheckEcmascript</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">1000000</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">primeCheck</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">%</span><span class="normal"> </span><span class="number">10000</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">9999</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> res</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">res</span><span class="symbol">.</span><span class="function">join</span><span class="symbol">(</span><span class="string">' '</span><span class="symbol">));</span>
<span class="cbracket">}</span>

</pre><p>Note that the program uses the native helper if it's available but falls
back to an Ecmascript version if it's not.  This allows the Ecmascript code
to be used in other containing programs.  Also, if the prime check program
is ported to another platform where the native version does not compile
without changes, the program remains functional (though slower) until the
helper is ported.  In this case the native helper detection happens when the
script is loaded.  You can also detect it when the code is actually called
which is more flexible.</p><p>A native helper with functionality equivalent to <code>primeCheckEcmascript</code>
is quite straightforward to implement.  Adding a program main we get
<code>primecheck.c</code>:</p><pre class="c-code"><span class="comment">/* primecheck.c */</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdio.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdlib.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;string.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"duktape.h"</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">native_prime_check</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">int</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="type">int</span><span class="normal"> lim </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="type">int</span><span class="normal"> i</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;=</span><span class="normal"> lim</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">val </span><span class="symbol">%</span><span class="normal"> i </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">duk_push_false</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">duk_push_true</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">int</span><span class="normal"> </span><span class="function">main</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> argc</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">argv</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>

<span class="normal">    ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Failed to create a Duktape heap.</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">duk_push_global_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> native_prime_check</span><span class="symbol">,</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_put_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"primeCheckNative"</span><span class="symbol">);</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_peval_file</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"prime.js"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> finished</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* ignore result */</span>

<span class="normal">    </span><span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"primeTest"</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_pcall</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* ignore result */</span>

<span class="label"> finished:</span>
<span class="normal">    </span><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>

<span class="normal">    </span><span class="function">exit</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>The new calls here are, line by line:</p><ul class="breakdown"> <!-- breakdown -->
<li>
<pre class="c-code"><span class="type">int</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="type">int</span><span class="normal"> lim </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
</pre>
<p>These two calls check the two argument values given to the native helper.
If the values are not of the Ecmascript number type, an error is thrown.
If they are numbers, their value is converted to an integer and assigned to
the <code>val</code> and <code>lim</code> locals.  The index 0 refers to the first
function argument and index 1 to the second.</p>
<p>
Technically <code>duk_require_int()</code> returns a <code>duk_int_t</code>; this
indirect type is always mapped to an <code>int</code> except on obscure platforms
where an <code>int</code> is only 16 bits wide.  In ordinary application code you
don't need to worry about this, see <a href="#ctypes">C types</a> for more discussion.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_push_false</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
</pre>
<p>Pushes an Ecmascript <code>false</code> to the value stack.  The C return value
1 indicates that the <code>false</code> value is returned to the Ecmascript caller.</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_push_global_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> native_prime_check</span><span class="symbol">,</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">);</span>
<span class="function">duk_put_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"primeCheckNative"</span><span class="symbol">);</span>
</pre>
<p>The first call, like before, pushes the Ecmascript global object to the
value stack.  The second call creates an Ecmascript <code>Function</code> object
and pushes it to the value stack.  The function object is bound to the
Duktape/C function <code>native_prime_check</code>: when the Ecmascript function
created here is called from Ecmascript, the C function gets invoked.
The second argument (<code>2</code>) to the call indicates how many arguments
the C function gets on the value stack.  If the caller gives fewer arguments,
the missing arguments are padded with <code>undefined</code>; if the caller gives
more arguments, the extra arguments are dropped automatically.  Finally, the
third call registers the function object into the global object with the
name <code>primeCheckNative</code> and pops the function value off the stack.
</p>
</li>
<li>
<pre class="c-code"><span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"primeTest"</span><span class="symbol">);</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_pcall</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="cbracket">}</span>
<span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">/* ignore result */</span>
</pre>
<p>When we come here the value stack already contains the global object
at the stack top.  Line 1 looks up the <code>primeTest</code> function
from the global object (which was defined by the loaded script).  Lines
2-4 call the <code>primeTest</code> function with zero arguments, and
prints out an error safely if one occurs.  Line 5 pops the call result
off the stack; we don't need the return value here.</p>
</li>
</ul><!-- breakdown --><p>Compile like above:</p><pre>
$ gcc -std=c99 -o primecheck -Isrc/ src/duktape.c primecheck.c -lm
</pre><p>Test run (ensure that <code>prime.js</code> is in the current directory):</p><pre>
$ time ./primecheck
Have native helper: true
49999 59999 79999 139999 179999 199999 239999 289999 329999 379999 389999
409999 419999 529999 599999 619999 659999 679999 769999 799999 839999 989999

real	0m2.985s
user	0m2.976s
sys	0m0.000s
</pre><p>Because most execution time is spent in the prime check, the speed-up
compared to plain Ecmascript is significant.  You can check this by editing
<code>prime.js</code> and disabling the use of the native helper:</p><pre class="ecmascript-code"><span class="comment">// Select available helper at load time</span>
<span class="keyword">var</span><span class="normal"> primeCheckHelper </span><span class="symbol">=</span><span class="normal"> primeCheckEcmascript</span><span class="symbol">;</span>
</pre><p>Re-compiling and re-running the test:</p><pre>
$ time ./primecheck
Have native helper: false
49999 59999 79999 139999 179999 199999 239999 289999 329999 379999 389999
409999 419999 529999 599999 619999 659999 679999 769999 799999 839999 989999

real	0m23.609s
user	0m23.573s
sys	0m0.000s
</pre><hr/><h1 class="sectiontitle" id="programming">Programming model <a class="sectionlink" href="#programming">§</a></h1><h2 class="sectiontitle" id="programming.1">Overview <a class="sectionlink" href="#programming.1">§</a></h2><p>Programming with Duktape is quite straightforward:</p><ul>
<li>Add Duktape source (<code>duktape.c</code>) and header (<code>duktape.h</code>)
    to your build.</li>
<li>Create a Duktape <b>heap</b> (a garbage collection region) and an initial
    <b>context</b> (essentially a thread handle) in your program.</li>
<li>Load the necessary Ecmascript script files, and register your Duktape/C
    functions.  Duktape/C functions are C functions you can call from
    Ecmascript code for better performance, bindings to native libraries, etc.</li>
<li>Use the Duktape API to call Ecmascript functions whenever appropriate.
    Duktape API is used to pass values to and from functions.  Values are
    converted between their C representation and the Duktape internal
    (Ecmascript compatible) representation.</li>
<li>Duktape API is also used by Duktape/C functions (called from Ecmascript)
    to access call arguments and to provide return values.</li>
</ul><p>Let's look at all the steps and their related concepts in more detail.</p><h2 class="sectiontitle" id="programming.2">Heap and context <a class="sectionlink" href="#programming.2">§</a></h2><p>A Duktape <b>heap</b> is a single region for garbage collection.  A heap
is used to allocate storage for strings, Ecmascript objects, and other
variable size, garbage collected data.  Objects in the heap have an internal
heap header which provides the necessary information for reference counting,
mark-and-sweep garbage collection, object finalization, etc.
Heap objects can reference each other, creating a reachability graph from
a garbage collection perspective.  For instance, the properties of an Ecmascript
object reference both the keys and values of the object's property set.  You can
have multiple heaps, but objects in different heaps cannot reference each other
directly; you need to use serialization to pass values between heaps.</p><p>A Duktape <b>context</b> is an Ecmascript "thread of execution" which lives
in a certain Duktape heap.  A context is represented by a <code>duk_context *</code>
in the Duktape API, and is associated with an internal Duktape coroutine (a form
of a co-operative thread).  Each context is also associated with an environment
consisting of global objects; contexts may share the same global environment but
can also have different environments.  The context handle is given to almost every
Duktape API call, and allows the caller to interact with the <b>value stack</b> of
the Duktape coroutine: values can be inserted and queries, functions can be called,
and so on.</p><p>Each coroutine has a <b>call stack</b> which controls execution, keeping
track of function calls, native or Ecmascript, within the Ecmascript engine.
Each coroutine also has a <b>value stack</b> which stores all the Ecmascript
values of the coroutine's active call stack.  The value stack always has an
active <b>stack frame</b> for the most recent function call (when no function
calls have been made, the active stack frame is the value stack as is).
The Duktape API calls operate almost exclusively in the currently active
stack frame.  A coroutine also has an internal <b>catch stack</b> which is used
to track error catching sites established using e.g. <code>try-catch-finally</code>
blocks.  This is not visible to the caller in any way at the moment.</p><p>Multiple contexts can share the same Duktape <b>heap</b>.  In more concrete
terms this means that multiple contexts can share the same garbage collection
state, and can exchange object references safely.  Contexts in different heaps
cannot exchange direct object references; all values must be serialized in one
way or another.</p><p>Almost every API call provided by the Duktape API takes a context pointer
as its first argument: no global variables or states are used, and there are
no restrictions on running multiple, independent Duktape heaps and contexts
at the same time.  There are multi-threading restrictions, however: only one
native thread can execute any code within a single heap at any time, see
<a href="#threading">Threading</a>.</p><p>To create a Duktape heap and an initial context inside the heap, you can
simply use:</p><pre class="c-code"><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">();</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
</pre><p>If you wish to provide your own memory allocation functions and a fatal
error handler function (recommended), use:</p><pre class="c-code"><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap</span><span class="symbol">(</span><span class="normal">my_alloc</span><span class="symbol">,</span>
<span class="normal">                                   my_realloc</span><span class="symbol">,</span>
<span class="normal">                                   my_free</span><span class="symbol">,</span>
<span class="normal">                                   my_udata</span><span class="symbol">,</span>
<span class="normal">                                   my_fatal</span><span class="symbol">);</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
</pre><p>To create a new context inside the same heap, with the context sharing the
same global objects:</p><pre class="c-code"><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">new_ctx</span><span class="symbol">;</span>

<span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="function">duk_push_thread</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">new_ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_get_context</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">);</span>
</pre><p>To create a new context inside the same heap, but with a fresh set of global
object:</p><pre class="c-code"><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">new_ctx</span><span class="symbol">;</span>

<span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="function">duk_push_thread_new_globalenv</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">new_ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_get_context</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="comment">/*index*/</span><span class="symbol">);</span>
</pre><p>Contexts are automatically garbage collected when they become unreachable.
This also means that if your C code holds a <code>duk_context *</code>, the
corresponding Duktape coroutine MUST be reachable from a garbage collection
point of view.</p><p>A heap must be destroyed explicitly when the caller is done with it:</p><pre class="c-code"><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
</pre><p>This frees all heap objects allocated, and invalidates any pointers to
such objects.  In particular, if the calling program holds string pointers
to values which resided on the value stack of a context associated with the
heap, such pointers are invalidated and must never be dereferenced after
the heap destruction call returns.</p><h2 class="sectiontitle" id="programming.3">Call stack and catch stack (of a context) <a class="sectionlink" href="#programming.3">§</a></h2><p>The call stack of a context is not directly visible to the caller.
It keeps track of the chain of function calls, either C or Ecmascript,
currently executing in a context.  The main purpose of this book-keeping is
to facilitate the passing of arguments and results between function callers
and callees, and to keep track of how the value stack is divided between
function calls.  The call stack also allows Duktape to construct a traceback
for errors.</p><p>Closely related to the call stack, Duktape also maintains a catch stack
for keeping track of current error catching sites established using e.g.
<code>try-catch-finally</code>.  The catch stack is even less visible to the
caller than the call stack.</p><p>Because Duktape supports tail calls, the call stack does not always
accurately represent the true call chain: tail calls will be "squashed"
together in the call stack.</p><div class="note">Don't confuse with the C stack.</div><h2 class="sectiontitle" id="programming.4">Value stack (of a context) and value stack index <a class="sectionlink" href="#programming.4">§</a></h2><p>The value stack of a context is an array of tagged type values related
to the current execution state of a coroutine.  The tagged types used are:
<code>undefined</code>, <code>null</code>, boolean, number, string, object, buffer,
and pointer.  For a detailed discussion of the available tagged types, see
<a href="#stacktypes">Types</a>.</p><p>The value stack is divided between the currently active function calls
(activations) on the coroutine's call stack.  At any time, there is an active
stack frame which provides an origin for indexing elements on the stack.
More concretely, at any time there is a <b>bottom</b> which is referred
to with the index zero in the Duktape API.  There is also a conceptual
<b>top</b> which identifies the stack element right above the highest
currently used element.  The following diagram illustrates this:</p><pre>
 Value stack
 of 10 entries
 (absolute indices)

.----.
| 15 |
| 14 |
| 13 |
| 12 |      Active stack frame (indices
| 11 |      relative to stack bottom)
| 10 |
|  9 |      .---.
|  8 |      | 5 |   API index 0 is bottom (at value stack index 3).
|  7 |      | 4 |
|  6 |      | 3 |   API index 5 is highest used (at value stack index 8).
|  5 |      | 2 |   
|  4 |      | 1 |   Stack top is 6 (relative to stack bottom).
|  3 | &lt;--- | 0 |
|  2 |      `---'
|  1 |
|  0 |
`----'
</pre><p>There is no direct way to refer to elements in the internal value stack:
Duktape API always deals with the currently active stack frame.  Stack frames
are shown horizontally throughout the documentation for space reasons.  For
example, the active stack frame in the figure above would be shown as:</p><div class="stack-wrapper"> <span class="stack"> <span class="cap">[</span> <span class="elem">0</span> <span class="elem">1</span> <span class="elem">2</span> <span class="elem">3</span> <span class="elem">4</span> <span class="elem">5</span> <span class="cap">]</span> </span> <span class="stack-comment"></span> </div><p>A <b>value stack index</b> is a signed integer index used in the Duktape
API to refer to elements in currently active stack frame, relative to the
current frame bottom.</p><p>Non-negative (&gt;= 0) indices refer to stack entries in the
current stack frame, relative to the frame bottom:</p><div class="stack-wrapper"> <span class="stack"> <span class="cap">[</span> <span class="elem">0</span> <span class="elem">1</span> <span class="elem">2</span> <span class="elem">3</span> <span class="elem">4</span> <span class="elem active">5</span> <span class="cap">]</span> </span> <span class="stack-comment"></span> </div><p>Negative (&lt; 0) indices refer to stack entries relative to the top:</p><div class="stack-wrapper"> <span class="stack"> <span class="cap">[</span> <span class="elem">-6</span> <span class="elem">-5</span> <span class="elem">-4</span> <span class="elem">-3</span> <span class="elem">-2</span> <span class="elem active">-1</span> <span class="cap">]</span> </span> <span class="stack-comment"></span> </div><p>The special constant <code>DUK_INVALID_INDEX</code> is a negative integer
which denotes an invalid stack index.  It can be returned from API calls
and can also be given to API calls to indicate a "no value".</p><p>The <b>value stack top</b> (or just "top") is the non-negative index of
an imaginary element just above the highest used index.  For instance, above
the highest used index is 5, so the stack top is 6.  The top indicates the
current stack size, and is also the index of the next element pushed to the
stack.</p><div class="stack-wrapper"> <span class="stack"> <span class="cap">[</span> <span class="elem">0</span> <span class="elem">1</span> <span class="elem">2</span> <span class="elem">3</span> <span class="elem">4</span> <span class="elem active">5</span> <span class="elem ghost">6</span> <span class="cap">]</span> </span> <span class="stack-comment"></span> </div><div class="note">
<p>API stack operations are always confined to the current stack frame.
There is no way to refer to stack entries below the current frame.  This
is intentional, as it protects functions in the call stack from affecting
each other's values.</p>
</div><div class="note">Don't confuse with the C stack.</div><h2 class="sectiontitle" id="programming.5">Growing the value stack <a class="sectionlink" href="#programming.5">§</a></h2><p>At any time, the value stack of a context is allocated for a certain
maximum number of entries.  An attempt to push values beyond the allocated
size will cause an error to be thrown, it will <b>not</b> cause the value
stack to be automatically extended.  This simplifies the internal
implementation and also improves performance by minimizing reallocations
when you know, beforehand, that a certain number of entries will be needed
during a function.</p><p>When a value stack is created or a Duktape/C function is entered, the
value stack is always guaranteed to have space for the call arguments and
<code>DUK_API_ENTRY_STACK</code> (currently 64) elements.  In the typical
case this is more than sufficient so that the majority of Duktape/C
functions don't need to extend the value stack.  Only functions that need
more space or perhaps need an input-dependent amount of space need to grow
the value stack.</p><p>You can extend the stack allocation explicitly with <code>duk_check_stack()</code>
or (usually more preferably) <code>duk_require_stack()</code>.  Once successfully
extended, you are again guaranteed that the specified number of elements can
be pushed to the stack.  There is no way to shrink the allocation except by
returning from a Duktape/C function.</p><p>Consider, for instance, the following function which will uppercase an
input ASCII string by pushing uppercased characters one-by-one on the stack
and then concatenating the result.  This example illustrates how the number
of value stack entries required may depend on the input (otherwise this is
not a very good approach for uppercasing a string):</p><pre class="ecmascript-code"><span class="comment">/* uppercase.c */</span>
<span class="normal">#include </span><span class="symbol">&lt;</span><span class="normal">stdio</span><span class="symbol">.</span><span class="normal">h</span><span class="symbol">&gt;</span>
<span class="normal">#include </span><span class="symbol">&lt;</span><span class="normal">stdlib</span><span class="symbol">.</span><span class="normal">h</span><span class="symbol">&gt;</span>
<span class="normal">#include </span><span class="string">"duktape.h"</span>

<span class="keyword">static</span><span class="normal"> int </span><span class="function">dummy_upper_case</span><span class="symbol">(</span><span class="normal">duk_context </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    size_t sz</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">const</span><span class="normal"> char </span><span class="symbol">*</span><span class="normal">val </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_lstring</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">sz</span><span class="symbol">);</span>
<span class="normal">    size_t i</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/* We're going to need 'sz' additional entries on the stack. */</span>
<span class="normal">    </span><span class="function">duk_require_stack</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> sz</span><span class="symbol">);</span>

<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> sz</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        char ch </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ch </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="string">'a'</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> ch </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="string">'z'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            ch </span><span class="symbol">=</span><span class="normal"> ch </span><span class="symbol">-</span><span class="normal"> </span><span class="string">'a'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'A'</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="function">duk_push_lstring</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> char </span><span class="symbol">*)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">ch</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">duk_concat</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> sz</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="normal">int </span><span class="function">main</span><span class="symbol">(</span><span class="normal">int argc</span><span class="symbol">,</span><span class="normal"> char </span><span class="symbol">*</span><span class="normal">argv</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    duk_context </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">argc </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">exit</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> dummy_upper_case</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> argv</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">    </span><span class="function">duk_call</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"%s -&gt; %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> argv</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">],</span><span class="normal"> </span><span class="function">duk_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>

<span class="normal">    </span><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>In addition to user reserved elements, Duktape keeps an automatic internal
value stack reserve to ensure all API calls have enough value stack space to
work without further allocations.  The value stack is also extended and shrunk
in somewhat large steps to minimize memory reallocation activity.  As a result
the internal number of value stack elements available beyond the caller
specified extra varies considerably.  The caller does not need to take this
into account and should never rely on any additional elements being available.</p><h2 class="sectiontitle" id="programming.6">Ecmascript array index <a class="sectionlink" href="#programming.6">§</a></h2><p>Ecmascript object and array keys can only be strings.  Array indices
(e.g. 0, 1, 2) are represented as canonical string representations of the
respective numbers.  More technically, all canonical string representations
of the integers in the range [0, 2**32-1] are valid array indices.</p><p>To illustrate the Ecmascript array index handling, consider the following
example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> arr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[</span><span class="normal"> </span><span class="string">'foo'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'bar'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'quux'</span><span class="normal"> </span><span class="symbol">];</span>

<span class="function">print</span><span class="symbol">(</span><span class="normal">arr</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span><span class="normal">     </span><span class="comment">// refers to 'bar'</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">arr</span><span class="symbol">[</span><span class="string">"1"</span><span class="symbol">]);</span><span class="normal">   </span><span class="comment">// refers to 'bar'</span>

<span class="function">print</span><span class="symbol">(</span><span class="normal">arr</span><span class="symbol">[</span><span class="number">1.0</span><span class="symbol">]);</span><span class="normal">   </span><span class="comment">// refers to 'bar', canonical encoding is "1"</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">arr</span><span class="symbol">[</span><span class="string">"1.0"</span><span class="symbol">]);</span><span class="normal"> </span><span class="comment">// undefined, not an array index</span>
</pre><p>Some API calls operating on Ecmascript arrays accept numeric array index
arguments.  This is really just a short hand for denoting a string conversion
of that number.  For instance, if the API is given the integer 123, this
really refers to the property name "123".</p><p>Internally, Duktape tries to avoid converting numeric indices to actual
strings whenever possible, so it is preferable to use array index API calls
when they are relevant.  Similarly, when writing Ecmascript code it is
preferable to use numeric rather than string indices, as the same fast path
applies for Ecmascript code.</p><h2 class="sectiontitle" id="duktape-api">Duktape API <a class="sectionlink" href="#duktape-api">§</a></h2><p>Duktape API is the collection of user callable API calls defined in
<code>duktape.h</code> and documented in the
<a href="api.html">API reference</a>.</p><p>The Duktape API calls are generally error tolerant and will check all
arguments for errors (such as <code>NULL</code> pointers).  However, to
minimize footprint, the <code>ctx</code> argument is not checked, and the
caller MUST NOT call any Duktape API calls with a <code>NULL</code> context.</p><p>All Duktape API calls are potentially macros.  Calling code must not rely
on any Duktape API call being available as a function pointer.  The
implementation of a certain API call may change between a macro and an
actual function even between compatible releases.  The Duktape API provides
the following guarantees for macros:</p><ul>
<li>Arguments are never evaluated more than once.  However, an argument may not
    be evaluated at all if an argument is ignored in the current version.</li>
<li>An API call with a return value can be used as an expression.  If the API
    macro contains multiple statements, it is implemented as a comma expression
    (e.g. <code>(foo, bar, quux)</code>).</li>
<li>An API call with a <code>void</code> return value may not necessarily work
    as part of an expression.  The API macro may be implemented as a block
    statement or as a dummy <code>do {...} while (0)</code> loop.</li>
</ul><h2 class="sectiontitle" id="programming.8">Duktape/C function <a class="sectionlink" href="#programming.8">§</a></h2><p>A C function with a Duktape/C API signature can be associated with an
Ecmascript function object, and gets called when the Ecmascript function
object is called.  A Duktape/C API function looks as follows:</p><pre class="c-code"><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_func</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">duk_push_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">123</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>The function gets Ecmascript call argument in the value stack of
<code>ctx</code>, with <code>duk_get_top(ctx)</code> indicating the number of
arguments present on the value stack.  When creating an Ecmascript function
object associated with a Duktape/C function, one can select the desired
number of arguments.  Extra arguments are dropped and missing arguments
are replaced with <code>undefined</code>.  A function can also be registered
as a vararg function (by giving <code>DUK_VARARGS</code> as the argument count)
in which case call arguments are not modified prior to C function entry.</p><p>The function can return one of the following:</p><ul>
<li>Return value 1 indicates that the value on the stack top is to be
    interpreted as a return value.</li>
<li>Return value 0 indicates that there is no explicit return value on
    the value stack; an <code>undefined</code> is returned to caller.</li>
<li>A negative return value indicates that an error is to be automatically
    thrown.  Error codes named <code>DUK_RET_xxx</code> map to specific kinds
    of errors (do not confuse these with <code>DUK_ERR_xxx</code> which are
    positive values).</li>
<li>A return value higher than 1 is currently undefined, as Ecmascript
    doesn't support multiple return values in Edition 5.1.  (Values higher
    than 1 may be taken into to support multiple return values in Ecmascript
    Edition 6.)</li>
</ul><p>A negative error return value is intended to simplify common error
handling, and is an alternative to constructing and throwing an error
explicitly with Duktape API calls.  No error message can be given; a
message is automatically constructed by Duktape.  For example:</p><pre class="c-code"><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_func</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_get_top</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* throw TypeError if no arguments given */</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> DUK_RET_TYPE_ERROR</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">/* ... */</span>
<span class="cbracket">}</span>
</pre><p>All Duktape/C functions are considered <b>strict</b> in the
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.2">Ecmascript sense</a>.
Duktape API calls always obey Ecmascript strict mode semantics, even when the API calls
are made outside of any Duktape/C function, i.e. with an empty call stack.
For instance, attempt to delete a non-configurable property using <code>duk_del_prop()</code>
will cause an error to be thrown.  This is the case with a strict Ecmascript function too:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">f</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="string">'use strict'</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> arr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="symbol">];</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">delete</span><span class="normal"> arr</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// array 'length' is non-configurable</span>
<span class="cbracket">}</span>

<span class="function">print</span><span class="symbol">(</span><span class="function">f</span><span class="symbol">());</span><span class="normal">  </span><span class="comment">// this throws an error because f() is strict</span>
</pre><p>Another consequence of Duktape/C function strictness is that the <code>this</code>
binding given to Duktape/C functions is not
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.3">coerced</a>.
This is also the case for strict Ecmascript code:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">strictFunc</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="string">'use strict'</span><span class="symbol">;</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> </span><span class="keyword">this</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">nonStrictFunc</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> </span><span class="keyword">this</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">strictFunc</span><span class="symbol">.</span><span class="function">call</span><span class="symbol">(</span><span class="string">'foo'</span><span class="symbol">);</span><span class="normal">     </span><span class="comment">// prints 'string' (uncoerced)</span>
<span class="normal">nonStrictFunc</span><span class="symbol">.</span><span class="function">call</span><span class="symbol">(</span><span class="string">'foo'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'object' (coerced)</span>
</pre><p>Duktape/C functions are currently always <b>constructable</b>, i.e. they
can always be used in <code>new Foo()</code> expressions.  You can check whether
a function was called in constructor mode as follows:</p><pre class="c-code"><span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_func</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_is_constructor_call</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"called as a constructor</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"called as a function</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
</pre><p>To save memory, Duktape/C functions don't have a <code>prototype</code>
property by default, so the default object instance (given to the constructor
as <code>this</code>) inherits from <code>Object.prototype</code>.  To use a
custom prototype you can define <code>prototype</code> for the Duktape/C
function explicitly.  Another approach is to ignore the default object instance
and construct one manually within the Duktape/C call: as with Ecmascript
functions, if a constructor returns an object value, that value replaces the
default object instance and becomes the value of the <code>new</code>
expression.</p><h2 class="sectiontitle" id="programming.9">Storing state for a Duktape/C function <a class="sectionlink" href="#programming.9">§</a></h2><p>Sometimes it would be nice to provide parameters or additional state
to a Duktape/C function out-of-band, i.e. outside explicit call arguments.
There are several ways to achieve this.</p><h3 class="sectiontitle" id="programming.9.1">Properties of function <a class="sectionlink" href="#programming.9.1">§</a></h3><p>First, a Duktape/C function can use its Function object to store state
or parameters.  A certain Duktape/C function (the actual C function)
is always represented by an Ecmascript Function object which is
internally associated with the underlying C function.   The Function
object can be used to store properties related to that particular
instance of the function.  Note that a certain Duktape/C function can
be associated with multiple independent Function objects and thus
independent states.</p><p>Accessing the Ecmascript Function object related to a Duktape/C function
is easy:</p><pre class="c-code"><span class="function">duk_push_current_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"my_state_variable"</span><span class="symbol">);</span>
</pre><h3 class="sectiontitle" id="programming.9.2">'this' binding <a class="sectionlink" href="#programming.9.2">§</a></h3><p>Another alternative for storing state is to call the Duktape/C function
as a method and then use the <code>this</code> binding for storing state.  For
instance, consider a Duktape/C function called as:</p><pre class="ecmascript-code"><span class="normal">foo</span><span class="symbol">.</span><span class="function">my_c_func</span><span class="symbol">()</span>
</pre><p>When called, the Duktape/C function gets <code>foo</code> as its <code>this</code>
binding, and one could store state directly in <code>foo</code>.  The difference
to using the Function object approach is that the same object is shared by all
methods, which has both advantages and disadvantages.</p><p>Accessing the <code>this</code> binding is easy:</p><pre class="c-code"><span class="function">duk_push_this</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"my_state_variable"</span><span class="symbol">);</span>
</pre><h3 class="sectiontitle" id="programming.9.3">Magic value of function <a class="sectionlink" href="#programming.9.3">§</a></h3><p>Duktape/C function objects can store an internal 16-bit signed integer "magic"
value (zero by default) with no extra memory cost.  The magic value can be used
to pass flags and/or small values to a Duktape/C function at minimal cost, so
that a single native function can provide slightly varied behavior for multiple
function objects:</p><pre class="c-code"><span class="comment">/* Magic value example: two lowest bits are used for a prefix index, bit 2 (0x04)</span>
<span class="comment"> * is used to select newline style for a log write helper.</span>
<span class="comment"> */</span>
<span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">prefix</span><span class="symbol">[</span><span class="number">4</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="string">"INFO"</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"WARN"</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"ERROR"</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"FATAL"</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="usertype">duk_int_t</span><span class="normal"> magic </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_get_current_magic</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>

<span class="function">printf</span><span class="symbol">(</span><span class="string">"%s: %s"</span><span class="symbol">,</span><span class="normal"> prefix</span><span class="symbol">[</span><span class="normal">magic </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x03</span><span class="symbol">],</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">));</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">magic </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x04</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"</span><span class="specialchar">\r\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>For an API usage example, see the test case
<a href="https://github.com/svaarala/duktape/blob/master/tests/api/test-get-set-magic.c">test-get-set-magic.c</a>.
Duktape uses magic values a lot internally to minimize size of compiled code, see e.g.
<a href="https://github.com/svaarala/duktape/blob/master/src/duk_bi_math.c">duk_bi_math.c</a>.</p><div class="note">
The magic value mechanism is liable to change between major Duktape versions,
as the number of available spare bits changes.  Use magic values only when it
really matters for footprint.  Properties stored on the function object is a
more stable alternative.
</div><h3 class="sectiontitle" id="programming.9.4">Heap stash <a class="sectionlink" href="#programming.9.4">§</a></h3><p>The heap stash is an object visible only from C code.  It is associated
with the Duktape heap, and allows Duktape/C code to store "under the hood"
state data which is not exposed to Ecmascript code.  It is accessed with the
<code>duk_push_heap_stash()</code> API call.</p><h3 class="sectiontitle" id="programming.9.5">Global stash <a class="sectionlink" href="#programming.9.5">§</a></h3><p>The global stash is like the heap stash, but is associated with a global
object.  It is accessed with the <code>duk_push_global_stash()</code> API
call.  There can be several environments with different global objects
within the same heap.</p><h3 class="sectiontitle" id="programming.9.6">Thread stash <a class="sectionlink" href="#programming.9.6">§</a></h3><p>The thread stash is like the heap stash, but is associated with a Duktape
thread (i.e. a <code>ctx</code> pointer).  It is accessible with the
<code>duk_push_thread_stash()</code> API call.</p><h2 class="sectiontitle" id="programming.10">Duktape version specific code <a class="sectionlink" href="#programming.10">§</a></h2><p>The Duktape version is available through the <code>DUK_VERSION</code> define,
with the numeric value <code>(major * 10000) + (minor * 100) + patch</code>.
The same value is available to Ecmascript code through <code>Duktape.version</code>.
Calling code can use this define for Duktape version specific code.</p><p>For C code:</p><pre class="c-code"><span class="preproc">#if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">DUK_VERSION </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">10203</span><span class="symbol">)</span>
<span class="comment">/* Duktape 1.2.3 or later */</span>
<span class="preproc">#elif</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">DUK_VERSION </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">800</span><span class="symbol">)</span>
<span class="comment">/* Duktape 0.8.0 or later */</span>
<span class="preproc">#else</span>
<span class="comment">/* Duktape lower than 0.8.0 */</span>
<span class="preproc">#endif</span>
</pre><p>For Ecmascript code (also see <a href="#duktapebuiltins">Duktape built-ins</a>):</p><pre class="ecmascript-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> Duktape </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'object'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'not Duktape'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">version </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">10203</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape 1.2.3 or higher'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">version </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">800</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape 0.8.0 or higher (but lower than 1.2.3)'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape lower than 0.8.0'</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><h2 class="sectiontitle" id="programming.11">Numeric error codes <a class="sectionlink" href="#programming.11">§</a></h2><p>When errors are created or thrown using the Duktape API, the caller
must assign a numeric error code to the error.  Error codes are
positive integers, with a range restricted to 24 bits at the
moment: the allowed error number range is thus [1,16777215].  Built-in
error codes are defined in <code>duktape.h</code>, e.g. <code>DUK_ERR_TYPE_ERROR</code>.</p><p>The remaining high bits are used internally to carry e.g. additional
flags.  Negative error values are used in the Duktape/C API as a
shorthand to automatically throw an error.</p><h2 class="sectiontitle" id="error-handling">Error handling <a class="sectionlink" href="#error-handling">§</a></h2><p>Error handling in the Duktape API is similar to how Ecmascript handles
errors: errors are thrown either explicitly or implicitly, then caught and
handled.  However, instead of a try-catch statement application code uses
<code><a href="api.html#taglist-protected">protected</a></code>
Duktape API calls to establish points in C code where errors can be caught
and handled.
An uncaught error causes the fatal error handler to be called, which is
considered an unrecoverable situation and should ordinarily be avoided
(see <a href="#error-fatal-panic">Error, fatal, and panic</a>).</p><p>To avoid fatal errors, typical application code should establish an error
catch point before making other Duktape API calls.  This is done using
protected Duktape API calls, for example:</p><ul>
<li>Use protected calls to evaluate code
    (<a href="api.html#duk_peval">duk_peval()</a>), compile code
    (<a href="api.html#duk_pcompile">duk_pcompile()</a>), and call
    (<a href="api.html#duk_pcall">duk_pcall()</a>) functions.</li>
<li>Use a single <a href="api.html#duk_safe_call">duk_safe_call()</a> to
    establish an error catcher so that you can use unsafe primitives freely
    inside the safe call.</li>
</ul><p>An example of the first technique:</p><pre class="c-code"><span class="comment">/* Use duk_peval() variant to evaluate a file so that script errors are</span>
<span class="comment"> * handled safely.  Both syntax errors and runtime errors are caught.</span>
<span class="comment"> */</span>

<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_peval_file</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"myscript.js"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Use duk_safe_to_string() to convert error into string.  This API</span>
<span class="comment">     * call is guaranteed not to throw an error during the coercion.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Script error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="cbracket">}</span>
<span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
</pre><p>An example of the second technique:</p><pre class="c-code"><span class="comment">/* Use duk_safe_call() to wrap all unsafe code into a separate C function.</span>
<span class="comment"> * This approach has the advantage of covering all API calls automatically</span>
<span class="comment"> * but is a bit more verbose.</span>
<span class="comment"> */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">unsafe_code</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Here we can use unprotected calls freely. */</span>
<span class="normal">    </span><span class="function">duk_eval_file_noresult</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"myscript.js"</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* ... */</span>

<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* success return, no return value */</span>
<span class="cbracket">}</span>

<span class="comment">/* elsewhere: */</span>

<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_safe_call</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> unsafe_code</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="comment">/*nrets */</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* The 'nrets' argument should be at least 1 so that an error value</span>
<span class="comment">     * is left on the stack if an error occurs.  To avoid further errors,</span>
<span class="comment">     * use duk_safe_to_string() for safe error printing.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"Unexpected error: %s</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="function">duk_safe_to_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">));</span>
<span class="cbracket">}</span>
<span class="function">duk_pop</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
</pre><p>Even within protected calls there are some rare cases, such as internal
errors, that will either cause a fatal error or propagate an error outwards
from a protected API call.  These should only happen in abnormal conditions
and are not considered recoverable.  To handle also these cases well, a
production quality application should always have a fatal error handler with
a reasonable strategy for dealing with fatal errors.  Such a strategy is
necessarily context dependent, but could be something like:</p><ul>
<li>On an embedded device the fatal error handler could write the fatal
    error information to a flash file and reboot the device.  After the
    reboot, the fatal error could be reported to a diagnostics server so
    that it can be investigated.</li>
<li>On a UNIX system the fatal error handler could simply exit the process
    (the default fatal handler uses <code>abort()</code>) and let a wrapper
    script restart the application.</li>
</ul><p>Note that it may be fine for some applications to make API calls without
an error catcher and risk throwing uncaught errors leading to a fatal error.
It's not possible to continue execution after a fatal error, so such
applications would typically simply exit when a fatal error occurs.  Even
without an actual recovery strategy, a fatal error handler should be used to
e.g. write fatal error information to <code>stderr</code> before process exit.</p><h2 class="sectiontitle" id="error-fatal-panic">Error, fatal, and panic <a class="sectionlink" href="#error-fatal-panic">§</a></h2><p>An <b>ordinary error</b> is caused by a <code>throw</code> statement,
a <code>duk_throw()</code> API call (or similar), or by an internal,
recoverable Duktape error.  Ordinary errors can be caught with a
<code>try-catch</code> in Ecmascript code or e.g. <code>duk_pcall()</code>
(see API calls tagged
<code><a href="api.html#taglist-protected">protected</a></code>)
in C code.</p><p>An uncaught error or an explicit call to <code>duk_fatal()</code> causes
a <b>fatal error</b> handler to be called.  A fatal error handler is
associated with every Duktape heap upon creation.  There is no reasonable way
to resume execution after a fatal error, so the fatal error handler must not
return.  The default fatal error handler writes an error message to <code>stderr</code>
and then escalates the fatal error to a panic (which, by default,
<code>abort()</code>s the process).  You can provide your own fatal error
handler to deal with fatal errors.  The most appropriate recovery action is,
of course, platform and application specific.  The handler could, for instance,
write a diagnostic file detailing the situation and then restart the application
to recover.</p><p>A <b>panic</b> is caused by Duktape assertion code (if included in the build)
or by the default fatal error handler.  There is no way to induce a panic from
user code.  The default panic handler writes an error message to <code>stderr</code>
and <code>abort()</code>s the process.  You can use the
<code>DUK_OPT_SEGFAULT_ON_PANIC</code> feature option to cause a deliberate
segfault instead of an <code>abort()</code>, which may be useful to get a stack
trace from some debugging tools.  You can also override the default panic
handler entirely with the feature option <code>DUK_OPT_PANIC_HANDLER</code>.
The panic handler is decided during build, while the fatal error handler is
decided at runtime by the calling application.</p><p>If assertions are turned off and the application provides a fatal error
handler, no panics will be caused by Duktape code.  All errors will then be
either ordinary errors or fatal errors, both under application control.</p><hr/><h1 class="sectiontitle" id="stacktypes">Stack types <a class="sectionlink" href="#stacktypes">§</a></h1><h2 class="sectiontitle" id="type-table">Overview <a class="sectionlink" href="#type-table">§</a></h2><div class="table-wrap">
<table>
<tr class="header"><th>Type</th><th>Type constant</th><th>Type mask constant</th><th>Description</th></tr>
<tr><td><a href="#type-none">(none)</a></td><td>DUK_TYPE_NONE</td><td>DUK_TYPE_MASK_NONE</td><td>no type (missing value, invalid index, etc)</td></tr>
<tr><td><a href="#type-undefined">undefined</a></td><td>DUK_TYPE_UNDEFINED</td><td>DUK_TYPE_MASK_UNDEFINED</td><td><code>undefined</code></td></tr>
<tr><td><a href="#type-null">null</a></td><td>DUK_TYPE_NULL</td><td>DUK_TYPE_MASK_NULL</td><td><code>null</code></td></tr>
<tr><td><a href="#type-boolean">boolean</a></td><td>DUK_TYPE_BOOLEAN</td><td>DUK_TYPE_MASK_BOOLEAN</td><td><code>true</code> and <code>false</code></td></tr>
<tr><td><a href="#type-number">number</a></td><td>DUK_TYPE_NUMBER</td><td>DUK_TYPE_MASK_NUMBER</td><td>IEEE double</td></tr>
<tr><td><a href="#type-string">string</a></td><td>DUK_TYPE_STRING</td><td>DUK_TYPE_MASK_STRING</td><td>immutable string</td></tr>
<tr><td><a href="#type-object">object</a></td><td>DUK_TYPE_OBJECT</td><td>DUK_TYPE_MASK_OBJECT</td><td>object with properties</td></tr>
<tr><td><a href="#type-buffer">buffer</a></td><td>DUK_TYPE_BUFFER</td><td>DUK_TYPE_MASK_BUFFER</td><td>mutable byte buffer, fixed/dynamic</td></tr>
<tr><td><a href="#type-pointer">pointer</a></td><td>DUK_TYPE_POINTER</td><td>DUK_TYPE_MASK_POINTER</td><td>opaque pointer (void *)</td></tr>
<tr><td><a href="#type-lightfunc">lightfunc</a></td><td>DUK_TYPE_LIGHTFUNC</td><td>DUK_TYPE_MASK_LIGHTFUNC</td><td>plain Duktape/C pointer (non-object)</td></tr>
</table>
</div><h2 class="sectiontitle" id="type-memory-allocations">Memory allocations <a class="sectionlink" href="#type-memory-allocations">§</a></h2><p>The following stack types involve additional heap allocations:</p><ul>
<li>String: a single allocation contains a combined heap and string header,
    followed by the immutable string data.</li>
<li>Object: one allocation is used for a combined heap and object header,
    and another allocation is used for object properties.  The property
    allocation contains both array entries and normal properties, and if
    the object is large enough, a hash table to speed up lookups.</li>
<li>Buffer: for fixed buffers a single allocation contains a combined heap
    and buffer header, followed by the mutable fixed-size buffer.  For
    dynamic buffers the current buffer is allocated separately.</li>
</ul><p>Note that while strings are considered a primitive (pass-by-value)
type in Ecmascript, they are a heap allocated type from a memory allocation
viewpoint.</p><h2 class="sectiontitle" id="type-pointer-stability">Pointer stability <a class="sectionlink" href="#type-pointer-stability">§</a></h2><p>Heap objects allocated by Duktape have stable pointers: the objects are
not relocated in memory while they are reachable from a garbage collection
point of view.  This is the case for the main heap object, but not
necessarily for any additional allocations related to the object, such as
dynamic property tables or dynamic buffer data area.  A heap object is
reachable e.g. when it resides on the value stack of a reachable thread or
is reachable through the global object.  Once a heap object becomes
unreachable any pointers held by user C code referring to the object are
unsafe and should no longer be dereferenced.</p><p>In practice the only heap allocated data directly referenced by user code
are strings, fixed buffers, and dynamic buffers.  The data area of strings
and fixed buffers is stable; it is safe to keep a C pointer referring to the
data even after a Duktape/C function returns as long the string or fixed
buffer remains reachable from a garbage collection point of view at all times.
Note that this is <i>not</i> the case for Duktape/C value stack arguments, for
instance, unless specific arrangements are made.</p><p>The data area of a dynamic buffer does <b>not</b> have a stable pointer.
The buffer itself has a heap header with a stable address but the current
buffer is allocated separately and potentially relocated when the buffer
is resized.  It is thus unsafe to hold a pointer to a dynamic buffer's data
area across a buffer resize, and it's probably best not to hold a pointer
after a Duktape/C function returns (as there would be no easy way of being
sure that the buffer hadn't been resized).</p><h2 class="sectiontitle" id="type-masks">Type masks <a class="sectionlink" href="#type-masks">§</a></h2><p>Type masks allows calling code to easily check whether a type belongs to
a certain type set.  For instance, to check that a certain stack value is
a number, string, or an object:</p><pre class="c-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_get_type_mask</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">DUK_TYPE_MASK_NUMBER </span><span class="symbol">|</span>
<span class="normal">                                  DUK_TYPE_MASK_STRING </span><span class="symbol">|</span>
<span class="normal">                                  DUK_TYPE_MASK_OBJECT</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"type is number, string, or object</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>There is a specific API call for matching a set of types even more
conveniently:</p><pre class="c-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_check_type_mask</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">,</span><span class="normal"> DUK_TYPE_MASK_NUMBER </span><span class="symbol">|</span>
<span class="normal">                                 DUK_TYPE_MASK_STRING </span><span class="symbol">|</span>
<span class="normal">                                 DUK_TYPE_MASK_OBJECT</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"type is number, string, or object</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>These are faster and more compact than the alternatives:</p><pre class="c-code"><span class="comment">// alt 1</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_is_number</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">duk_is_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">duk_is_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"type is number, string, or object</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">// alt 2</span>
<span class="type">int</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_get_type</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">);</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> DUK_TYPE_NUMBER </span><span class="symbol">||</span><span class="normal"> t </span><span class="symbol">==</span><span class="normal"> DUK_TYPE_STRING </span><span class="symbol">||</span><span class="normal"> t </span><span class="symbol">==</span><span class="normal"> DUK_TYPE_OBJECT</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">printf</span><span class="symbol">(</span><span class="string">"type is number, string, or object</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><h2 class="sectiontitle" id="type-none">None <a class="sectionlink" href="#type-none">§</a></h2><p>The <b>none</b> type is not actually a type but is used in the API to
indicate that a value does not exist, a stack index is invalid, etc.</p><h2 class="sectiontitle" id="type-undefined">Undefined <a class="sectionlink" href="#type-undefined">§</a></h2><p>The <b>undefined</b> type maps to Ecmascript <code>undefined</code>, which is
distinguished from a <code>null</code>.</p><p>Values read from outside the active value stack range read back as
<b>undefined</b>.</p><h2 class="sectiontitle" id="type-null">Null <a class="sectionlink" href="#type-null">§</a></h2><p>The <b>null</b> type maps to Ecmascript <code>null</code>.</p><h2 class="sectiontitle" id="type-boolean">Boolean <a class="sectionlink" href="#type-boolean">§</a></h2><p>The <b>boolean</b> type is represented in the C API as an integer: zero for false,
and non-zero for true.</p><p>Whenever giving boolean values as arguments in API calls, any non-zero value is
accepted as a "true" value.  Whenever API calls return boolean values, the value
<code>1</code> is always used for a "true" value.  This allows certain C idioms to be
used.  For instance, a bitmask can be built directly based on API call return values,
as follows:
</p><pre class="c-code"><span class="comment">// this works and generates nice code</span>
<span class="type">int</span><span class="normal"> bitmask </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">);</span>

<span class="comment">// more verbose variant not relying on "true" being represented by 1</span>
<span class="type">int</span><span class="normal"> bitmask </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="symbol">((</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="comment">// another verbose variant</span>
<span class="type">int</span><span class="normal"> bitmask </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span>
<span class="normal">              </span><span class="symbol">(</span><span class="function">duk_get_boolean</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
</pre><h2 class="sectiontitle" id="type-number">Number <a class="sectionlink" href="#type-number">§</a></h2><p>The <b>number</b> type is an IEEE double, including +/- Infinity and NaN values.
Zero sign is also preserved.  An IEEE double represents all integers up to 53 bits
accurately.</p><p>IEEE double allows NaN values to have additional signaling bits.  Because these
bits are used by Duktape internal tagged type representation (when using 8-byte
packed values), NaN values in the Duktape API are normalized.  Concretely, if you
push a certain NaN value to the value stack, another (normalized) NaN value may
come out.  Don't rely on NaNs preserving their exact form.</p><h2 class="sectiontitle" id="type-string">String <a class="sectionlink" href="#type-string">§</a></h2><p>The <b>string</b> type is an arbitrary byte sequence of a certain length which
may contain internal NUL (0x00) values.  Strings are always automatically NUL
terminated for C coding convenience.  The NUL terminator is not counted as part
of the string length.  For instance, the string <code>"foo"</code> has byte length 3
and is stored in memory as <code>{ 'f', 'o', 'o', '\0' }</code>.  Because of the
guaranteed NUL termination, strings can always be pointed to using a simple
<code>const char *</code> as long as internal NULs are not an issue; if they are,
the explicit byte length of the string can be queried with the API.  Calling code
can refer directly to the string data held by Duktape.  Such string data
pointers are valid (and stable) for as long as a string is reachable in the
Duktape heap.</p><p>Strings are <a href="http://en.wikipedia.org/wiki/String_interning">interned</a>
for efficiency: only a single copy of a certain string ever exists at a time.
Strings are immutable and must NEVER be changed by calling C code.  Doing so will
lead to very mysterious issues which are hard to diagnose.</p><p>Calling code most often deals with Ecmascript strings, which may contain
arbitrary 16-bit codepoints (the whole range U+0000 to U+FFFF) but cannot represent
non-<a href="http://en.wikipedia.org/wiki/Basic_Multilingual_Plane#Basic_Multilingual_Plane">BMP</a>
codepoints (this is how strings are defined in the Ecmascript standard).
In Duktape, Ecmascript strings are encoded with
<a href="http://en.wikipedia.org/wiki/CESU-8">CESU-8</a> encoding.  CESU-8
matches <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> except that it
allows codepoints in the surrogate pair range (U+D800 to U+DFFF) to be encoded
directly; these are prohibited in UTF-8.  CESU-8, like UTF-8, encodes all 7-bit
ASCII characters as-is which is convenient for C code.  For example:</p><ul>
<li>U+0041 ("A") encodes to <code>41</code>.</li>
<li>U+1234 (ETHIOPIC SYLLABLE SEE) encodes to <code>e1 88 b4</code>.</li>
<li>U+D812 (high surrogate) encodes to <code>ed a0 92</code> (this would be
    <a href="http://en.wikipedia.org/wiki/UTF-8#Invalid_code_points">invalid UTF-8</a>).</li>
</ul><a name="extended-utf8"></a><p>Duktape also uses extended strings internally.  Codepoints up to U+10FFFF
can be represented with UTF-8, and codepoints above that up to full 32 bits
can be represented with
<a href="http://en.wikipedia.org/wiki/UTF-8#Extending_from_31_bit_to_36_bit_range">extended UTF-8</a>.
Non-standard strings are used for storing internal object properties; using a
non-standard string ensures that such properties never conflict with properties
accessible using standard Ecmascript strings.  Non-standard strings can be given
to Ecmascript built-in functions, but since behavior may not be exactly
specified, results may vary.</p><p>The extended UTF-8 encoding used by Duktape is described in the table below.
The leading byte is shown in binary (with "x" marking data bits) while
continuation bytes are marked with "C" (indicating the bit sequence 10xxxxxx):</p><table>
<thead>
<tr class="header"><th>Codepoint range</th><th>Bits</th><th>Byte sequence</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>U+0000 to U+007F</td><td>7</td><td>0xxxxxxx</td><td></td></tr>
<tr><td>U+0080 to U+07FF</td><td>11</td><td>110xxxxx C</td><td></td></tr>
<tr><td>U+0800 to U+FFFF</td><td>16</td><td>1110xxxx C C</td><td>U+D800 to U+DFFF allowed (unlike UTF-8)</td></tr>
<tr><td>U+1 0000 to U+1F FFFF</td><td>21</td><td>11110xxx C C C</td><td>Above U+10FFFF allowed (unlike UTF-8)</td></tr>
<tr><td>U+20 0000 to U+3FF FFFF</td><td>26</td><td>111110xx C C C C</td><td></td></tr>
<tr><td>U+400 0000 to U+7FFF FFFF</td><td>31</td><td>1111110x C C C C C</td><td></td></tr>
<tr><td>U+8000 0000 to U+F FFFF FFFF</td><td>36</td><td>11111110 C C C C C C</td><td>Only 32 bits used in practice (up to U+FFFFFFFF)</td></tr>
</tbody>
</table><p>The downside of the encoding for codepoints above U+7FFFFFFF is that
the leading byte will be <code>0xFE</code> which conflicts with Unicode byte order
marker encoding.  This is not a practical concern in Duktape's internal use.</p><p>The leading <code>0xFF</code> byte never appears in Duktape's extended UTF-8
encoding, and is used to implement <a href="#internalproperties">internal properties</a>.</p><h2 class="sectiontitle" id="type-object">Object <a class="sectionlink" href="#type-object">§</a></h2><p>The <b>object</b> type includes Ecmascript objects and arrays, functions, and
threads (coroutines).  In other words, anything with properties is an object.
Properties are key-value pairs with a string key and an arbitrary value
(including <b>undefined</b>).</p><p>Objects may participate in garbage collection finalization.</p><h2 class="sectiontitle" id="type-buffer">Buffer <a class="sectionlink" href="#type-buffer">§</a></h2><p>The <b>buffer</b> type is a raw buffer for user data of either fixed or dynamic
size.  The size of a fixed buffer is given at its creation, and fixed buffers
have an unchanging (stable) data pointer.  Dynamic buffers may change during their
life time at the cost of having a (potentially) changing data pointer.  Dynamic
buffers also need two memory allocations internally, while fixed buffers only
need one.  The data pointer of a zero-size dynamic buffer may (or may not) be
<code>NULL</code> which must be handled by calling code properly (i.e. a <code>NULL</code>
data pointer only indicates an error if the requested size is non-zero).
Unlike strings, buffer data areas are not automatically NUL terminated and calling
code must not access the bytes following the allocated buffer size.</p><p>Buffers are automatically garbage collected.  This also means that C code
must not hold onto a buffer data pointer unless the buffer is reachable to
Duktape, e.g. resides in an active value stack.</p><p>The buffer type is not standard Ecmascript.  There are a few
different Ecmascript typed array specifications, though, see e.g.
<a href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a>.
These will be implemented on top of raw arrays, most likely.
</p><p>Like strings, buffer values have a <code>length</code> property and
array index properties for reading and writing individual bytes in the buffer.
The value of a indexed byte (<code>buf[123]</code>) is a number in the
range 0...255 which represents a byte value (written values are coerced to
integer modulo 256).  This differs from string behavior where the indexed
values are one-character strings (much more expensive).  The <code>length</code>
property is read-only at the moment (so you can't resize a string by assigning
to the length property).  These properties are available for both plain buffer
values and buffer object values.</p><p>A few notes:</p><ul>
<li>Because the value written to a buffer index is number coerced, assigning
a one-character value does not work as often expected.  For instance, 
<code>buf[123] = 'x'</code> causes zero to be written to the buffer, as
ToNumber('x') = 0.  For clarity, you should only assign number values,
e.g. <code>buf[123] = 0x78</code>.</li>
<li>There is a fast path for reading and writing numeric indices of plain buffer
values, e.g. <code>x = buf[123]</code> or <code>buf[123] = x</code>.  This
fast path is not active when the base value is a Buffer object (the indexes are
readable but go through slower processing).</li>
<li>Buffer virtual properties are not currently implemented in
<code>defineProperty()</code>, so you can't write to buffer indices or
buffer <code>length</code> with <code>defineProperty()</code> now (attempt
to do so results in a <code>TypeError</code>).</li>
</ul><h2 class="sectiontitle" id="type-pointer">Pointer <a class="sectionlink" href="#type-pointer">§</a></h2><p>The <b>pointer</b> type is a raw, uninterpreted C pointer, essentially
a <code>void *</code>.  Pointers can be used to point to native objects (memory
allocations, handles, etc), but because Duktape doesn't know their use, they
are not automatically garbage collected.  You can, however, put one or more
pointers inside an object and use the object finalizer to free the
native resources related to the pointer(s).</p><h2 class="sectiontitle" id="type-lightfunc">Lightfunc <a class="sectionlink" href="#type-lightfunc">§</a></h2><p>The <b>lightfunc</b> type is a plain Duktape/C function pointer and a small
set of control flags packed into a single tagged value which requires no further
heap allocations.  The control flags (16 bits currently) encode:
(1) number of stack arguments expected by the Duktape/C function (0 to 14 or
varargs), (2) virtual <code>length</code> property value (0 to 15), and
(3) a magic value (-128 to 127).  Because a lightfunc is a plain tagged
value, it cannot hold any actual own property values; it has a few virtual
properties and inherits other properties through <code>Function.prototype</code>.</p><p>Lightfuncs are a separate tagged type in the Duktape C API, but behave mostly
like Function objects for Ecmascript code.  They have significant limitations
compared to ordinary Function objects, the most important being:</p><ul>
<li>Lightfuncs cannot hold own properties and have a fixed virtual <code>name</code>
    which appears in tracebacks, etc.</li>
<li>Lightfuncs can be used as constructor functions, but cannot have a
    <code>prototype</code> property.  If you need to construct objects which
    don't inherit from <code>Object.prototype</code> (the default), you need to
    construct and return an instance explicitly in the constructor.</li>
<li>Lightfuncs can be used as accessor properties (getters/setters), but they
    get converted to actual functions; see
    <a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-dev-lightfunc-accessor.js">test-dev-lightfunc-accessor.js</a>.</li>
<li>Lightfuncs cannot have a finalizer as they are a primitive type and
    don't have a reference count field or otherwise participate in garbage
    collection; see
    <a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-dev-lightfunc-finalizer.js">test-dev-lightfunc-finalizer.js</a>.</li>
</ul><p>Lightfuncs are useful for very low memory environments where the memory
impact of ordinary Function objects matters.  For more discussion, see
<a href="#duktapec-lightfunc-properties">Properties of lightweight Duktape/C functions</a>,
<a href="#typealgorithms">Type algorithms</a>,
and
<a href="https://github.com/svaarala/duktape/blob/master/doc/lightweight-functions.rst">lightweight-functions.rst</a>.</p><hr/><h1 class="sectiontitle" id="ctypes">C types <a class="sectionlink" href="#ctypes">§</a></h1><p>Duktape API uses typedef-wrapped C types almost exclusively to ensure
portability to exotic platforms.  This section provides some background,
summarizes the types, and describes how calling code should use types to
maximize portability.</p><p>Portable C/C++ typing is a complex issue, involving:</p><ul>
<li>Portable type detection for C99/C++11 and older environments</li>
<li>Bit sizes and ranges of available types, selecting the most appropriate
    types, e.g. fastest or smallest with a guaranteed minimum or exact bit size</li>
<li>Constants for type ranges, such as <code>INT_MIN</code></li>
<li>Format specifiers when types are used in <code>printf()</code> and
    <code>scanf()</code> format strings</li>
</ul><p>Duktape only works on platforms with
<a href="http://en.wikipedia.org/wiki/Two's_complement">two's complement</a>
arithmetic.</p><h2 class="sectiontitle" id="ctypes.1">Guidelines for code using the Duktape API <a class="sectionlink" href="#ctypes.1">§</a></h2><ul>
<li>Use Duktape types such as <code>duk_idx_t</code> and <code>duk_ret_t</code>
(described below) when declaring variables for maximum portability.  Alternatively
you may use plain types (like <code>long</code>) but your code will be less portable
and you may need to use casts to avoid warnings.  Note that <code>long</code> is a
better default integer type than <code>int</code>, because <code>int</code> may be
only 16 bits wide on some platforms.</li>
<li>Duktape types like <code>duk_int_t</code> have been chosen to be the most
convenient (or fastest) types for the compiler.  If you're using them in
structs whose footprint matters, you may want to use other C types; remember
to check / cast accordingly.</li>
<li>In <code>printf()</code> formatting cast Duktape types to a wide integer
type and use a standard format specific to ensure that the type and the
specifier always match.  For integers, <code>long</code> and <code>unsigned long</code>
are usually a good choice because they don't require C99/C++11 and can usually
hold all integer values used by Duktape typedefs.  For example:
<pre class="c-code"><span class="function">printf</span><span class="symbol">(</span><span class="string">"Result: %ld</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">long</span><span class="symbol">)</span><span class="normal"> </span><span class="function">duk_get_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">3</span><span class="symbol">));</span>
</pre>
</li>
<li>Duktape API calls which support ANSI C format strings simply pass on the
format string and call arguments to the platform's <code>vsnprintf()</code>
function.  To maximize portability, select format specifiers carefully and
cast arguments to ensure types match.  For example:
<pre class="c-code"><span class="usertype">duk_int_t</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="number">123</span><span class="symbol">;</span>
<span class="function">duk_push_sprintf</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"My integer: %ld"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">long</span><span class="symbol">)</span><span class="normal"> val</span><span class="symbol">);</span>
</pre>
</li>
<li>A few standard format specifiers:
    <ul>
<li><code>long</code>: <code>%ld</code></li>
<li><code>unsigned long</code>: <code>%lu</code></li>
<li><code>double</code>: <code>%f</code> or <code>%lf</code> for <code>printf()</code>,
        <code>%lf</code> for <code>scanf()</code></li>
<li><code>size_t</code>: <code>%zu</code> (C99; pre-C99 compilers have various custom specifiers)</li>
<li><code>intmax_t</code>: <code>%jd</code> (C99)</li>
<li><code>uintmax_t</code>: <code>%ju</code> (C99)</li>
</ul>
</li>
<li>Format specifiers used by <code>printf()</code> and <code>scanf()</code>
may be different.  For <code>scanf()</code>, use a standard type and a
standard format code (so that you can be certain they match), then cast
to a Duktape type as necessary.  Again, <code>long</code> and <code>unsigned long</code>
are a good default choice.  For example:
<pre class="c-code"><span class="type">long</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="function">sscanf</span><span class="symbol">(</span><span class="normal">my_str</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"%ld"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">val</span><span class="symbol">);</span>
<span class="function">duk_push_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">duk_int_t</span><span class="symbol">)</span><span class="normal"> val</span><span class="symbol">);</span>
</pre>
</li>
<li>Use the <code>L</code> (or <code>UL</code>) suffix for constants which
are larger than 16 bits to maximize portability.  Like the <code>int</code>
type, integer constants without a suffix are only guaranteed to be 16 bits
wide.  With the <code>L</code> suffix constants are guaranteed to be at least
32 bits wide.  Example:
<pre class="c-code"><span class="function">duk_push_int</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1234567L</span><span class="symbol">);</span>
</pre>
</li>
<li>Duktape API calls with a filesystem path argument simply pass the
path to <code>fopen()</code>.  There is no way to specify an encoding
or support a wide character set.  To do that, you need to implement a
platform specific helper yourself.</li>
</ul><h2 class="sectiontitle" id="ctypes.2">Wrapped types used in the Duktape API <a class="sectionlink" href="#ctypes.2">§</a></h2><p>For the most part you don't need to worry about these type wrappers:
they're intended for exotic environments where some common assumptions
about type bit counts and such don't hold.</p><p>The API documentation uses the Duktape wrapped typedef names (such as
<code>duk_idx_t</code>).  The concrete type used by the compiler depends
on your platform and compiler.  When hovering over a prototype in the API
documentation the tool tip will show what concrete types are used when
C99/C++11 types are available and the platform <code>int</code> is at least
32 bits wide (which is nowadays almost always the case).</p><p>The following table summarizes a few central typedefs and what the
concrete type selected will be in various (example) environments.  The
table also suggests what plain type you should use for <code>printf()</code>
and <code>scanf()</code> casts for portable formatting/scanning.</p><table>
<tr>
<th>Duktape type</th>
<th class="highlight">C99/C++11 32-bit int</th>
<th>Legacy 32-bit int</th>
<th>Legacy 16-bit int</th>
<th><code>printf</code></th>
<th><code>scanf</code></th>
<th>Notes</th>
</tr>
<tr>
<td>duk_int_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>long</td>
<td>%ld<br/>long</td>
<td>%ld<br/>long</td>
<td>All around integer type, range is [<code>DUK_INT_MIN</code>, <code>DUK_INT_MAX</code>]</td>
</tr>
<tr>
<td>duk_uint_t</td>
<td class="highlight">unsigned int</td>
<td>unsigned int</td>
<td>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>All around unsigned integer type, range is [0, <code>DUK_UINT_MAX</code>]</td>
</tr>
<tr>
<td>duk_int32_t</td>
<td class="highlight">int32_t</td>
<td>int</td>
<td>long</td>
<td>%ld<br/>long</td>
<td>%ld<br/>long</td>
<td>Exact type for <code>ToInt32()</code> coercion</td>
</tr>
<tr>
<td>duk_uint32_t</td>
<td class="highlight">uint32_t</td>
<td>unsigned int</td>
<td>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>Exact type for <code>ToUint32()</code> coercion</td>
</tr>
<tr>
<td>duk_uint16_t</td>
<td class="highlight">uint16_t</td>
<td>unsigned short</td>
<td>unsigned short</td>
<td>%u<br/>unsigned int</td>
<td>%u<br/>unsigned int</td>
<td>Exact type for <code>ToUint16()</code> coercion</td>
</tr>
<tr>
<td>duk_idx_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>long</td>
<td>%ld<br/>long</td>
<td>%ld<br/>long</td>
<td>Value stack index</td>
</tr>
<tr>
<td>duk_uarridx_t</td>
<td class="highlight">unsigned int</td>
<td>unsigned int</td>
<td>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>Ecmascript array index</td>
</tr>
<tr>
<td>duk_codepoint_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>long</td>
<td>%ld<br/>long</td>
<td>%ld<br/>long</td>
<td>Unicode codepoints</td>
</tr>
<tr>
<td>duk_errcode_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>long</td>
<td>%ld<br/>long</td>
<td>%ld<br/>long</td>
<td>Integer error codes used in the Duktape API (range for user codes is [1,16777215])</td>
</tr>
<tr>
<td>duk_bool_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>int</td>
<td>%d<br/>int</td>
<td>%d<br/>int</td>
<td>Boolean return values</td>
</tr>
<tr>
<td>duk_ret_t</td>
<td class="highlight">int</td>
<td>int</td>
<td>int</td>
<td>%d<br/>int</td>
<td>%d<br/>int</td>
<td>Return value from Duktape/C function</td>
</tr>
<tr>
<td>duk_size_t</td>
<td class="highlight">size_t</td>
<td>size_t</td>
<td>size_t</td>
<td>%lu<br/>unsigned long</td>
<td>%lu<br/>unsigned long</td>
<td>1:1 mapping now, wrapped for future use.  Range is [0, <code>DUK_SIZE_MAX</code>].
    C99 format specifier is <code>%zu</code>.</td>
</tr>
<tr>
<td>duk_double_t</td>
<td class="highlight">double</td>
<td>double</td>
<td>double</td>
<td>%f or %lf<br/>double</td>
<td>%lf<br/>double</td>
<td>1:1 mapping now, wrapped for future use, e.g. custom software floating point library.</td>
</tr>
</table><h2 class="sectiontitle" id="ctypes.3">Background on C/C++ typing issues <a class="sectionlink" href="#ctypes.3">§</a></h2><p>This section provides some background and rationale for the C typing.</p><h3 class="sectiontitle" id="ctypes.3.1">Bit sizes are not standard (and there's no guaranteed fast 32-bit type) <a class="sectionlink" href="#ctypes.3.1">§</a></h3><p>Bit sizes of common types like <code>int</code> vary across implementations.
C99/C++11 provide standard integer typedefs like <code>int32_t</code> (exact
signed 32-bit type) and <code>int_fast32_t</code> (fast integer type which
has at least signed 32-bit range).  These typedefs are not available in
older compilers, so platform dependent type detection is necessary.</p><p>Duktape needs an integer type which is convenient for the architecture but
still guaranteed to be 32 bits wide.  Such a type is needed to represent array
indices, Unicode points, etc.  However, there is no such standard type and at
least the following variations are seen:</p><ul>
<li>a 16-bit <code>int</code> and a 32-bit <code>long</code></li>
<li>a 32-bit <code>int</code> and a 64-bit <code>long</code>, with the 64-bit
    <code>long</code> being inefficient for the processor</li>
<li>a 64-bit <code>int</code> and <code>long</code></li>
</ul><p>As can be seen, no built-in C type would be appropriate, so type detection
is needed.  Duktape detects and defines <code>duk_int_t</code> type for these
purposes (at least 32 bits wide, convenient to the CPU).  Normally it is mapped
to <code>int</code> if Duktape can reliably detect that <code>int</code> is 32
bits or wider.  When this is not the case, <code>int_fast32_t</code> is used
if C99 types are available; if C99 is not available, Duktape uses platform
specific detection to arrive at an appropriate type.  The <code>duk_uint_t</code>
is the same but unsigned.  Most other types in the API (such as <code>duk_idx_t</code>)
are mapped to <code>duk_(u)int_t</code> but this may change in the future
if necessary.</p><p>Other special types are also needed.  For instance, exactly N bits wide
integers are also needed to ensure proper overflow behavior in some cases.</p><h3 class="sectiontitle" id="ctypes.3.2">Format specifiers <a class="sectionlink" href="#ctypes.3.2">§</a></h3><p>C/C++ types are often used with <code>printf()</code> and <code>scanf()</code>,
with each type having a format specifier.  The set of format specifiers is only
partially standardized (e.g. <code>%d</code> is used for an <code>int</code>,
regardless of its bit size), but custom codes are sometimes used.</p><p>When using type wrappers, the correct format code depends on type detection.
For instance, <code>duk_int_t</code> is mapped to a convenient integer type which is
at least 32 bits wide.  On one platform the underlying type might be <code>int</code>
(format specifier <code>%d</code>) and on another it might be <code>long</code>
(format specifier <code>%ld</code>).  Calling code cannot safely use such a value
in string formatting without either getting the proper format specified from a
preprocessor define or using a fixed format specifier and casting the argument:</p><pre class="c-code"><span class="usertype">duk_int_t</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="comment">/* ... */</span><span class="symbol">;</span>

<span class="comment">/* Cast value to ensure type and format match.  Selecting the appropriate</span>
<span class="comment"> * cast target is problematic, and caller must "play it safe".  Without</span>
<span class="comment"> * relying on C99 types, "long" is usually good for signed integers.</span>
<span class="comment"> */</span>
<span class="function">printf</span><span class="symbol">(</span><span class="string">"value is: %ld</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">long</span><span class="symbol">)</span><span class="normal"> val</span><span class="symbol">);</span>

<span class="comment">/* When assuming C99 types (which limits portability), the maxint_t is</span>
<span class="comment"> * guaranteed to represent all signed integers and has a standard format</span>
<span class="comment"> * specifiers "%jd".  For unsigned values, umaxint_t and "%ju".</span>
<span class="comment"> */</span>
<span class="function">printf</span><span class="symbol">(</span><span class="string">"value is: %jd</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">maxint_t</span><span class="symbol">)</span><span class="normal"> val</span><span class="symbol">);</span>

<span class="comment">/* Use a preprocessor define to provide the format code.  Code and format</span>
<span class="comment"> * specifier are chosen to match during type detection.</span>
<span class="comment"> */</span>
<span class="function">printf</span><span class="symbol">(</span><span class="normal">DUK_PRIdINT</span><span class="symbol">,</span><span class="normal"> val</span><span class="symbol">);</span>
</pre><p>C99 takes this approach and provides preprocessor defines for C99 types in
<code>inttypes.h</code>.  For instance, the <code>printf()</code> decimal
format specifier for <code>int_fast32_t</code> is <code>PRIdFAST32</code>:</p><pre class="c-code"><span class="usertype">int_fast32_t</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="comment">/* ... */</span><span class="symbol">;</span>

<span class="function">printf</span><span class="symbol">(</span><span class="string">"value is: "</span><span class="normal"> PRIdFAST32 </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> val</span><span class="symbol">);</span>
</pre><p>The <code>printf()</code> and <code>scanf()</code> format specifiers may
be different.  One reason is that <code>float</code> arguments are automatically
promoted to <code>double</code> in <code>printf()</code> but they are handled
as distinct types by <code>scanf()</code>.  See
<a href="http://stackoverflow.com/questions/210590/why-does-scanf-need-lf-for-doubles-when-printf-is-okay-with-just-f">why-does-scanf-need-lf-for-doubles-when-printf-is-okay-with-just-f</a>.</p><p>The correct format specifier for a <code>double</code> in
<code>printf()</code> is <code>%f</code> (float values are automatically
promoted to doubles) but <code>%lf</code> is also accepted.  The latter is
used in Duktape examples for clarity.  See
<a href="http://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf">correct-format-specifier-for-double-in-printf</a>.</p><hr/><h1 class="sectiontitle" id="typealgorithms">Type algorithms <a class="sectionlink" href="#typealgorithms">§</a></h1><p>This section describes how type-related Ecmascript algorithms
like comparisons and coercions are extended to Duktape custom types.
Duktape specific type algorithms (<code>ToBuffer()</code> and <code>ToPointer()</code>)
are also discussed.</p><h2 class="sectiontitle" id="typealgorithms.1">Notation <a class="sectionlink" href="#typealgorithms.1">§</a></h2><p>The following shorthand is used to indicate how values are compared:</p><table class="typeshorthand">
<thead>
<tr><th>Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>t</td><td>compares to true</td></tr>
<tr><td>f</td><td>compares to false</td></tr>
<tr><td>s</td><td>simple compare: boolean-to-boolean, string-to-string (string contents compared), buffer-to-buffer
                  (buffer contents compared), buffer-to-string (buffer and string contents compared)</td></tr>
<tr><td>n</td><td>number compare: NaN values compare false, zeroes compare true regardless of sign (e.g. +0 == -0)</td></tr>
<tr><td>N</td><td>number compare in SameValue: NaN values compare true, zeroes compare with sign (e.g. SameValue(+0,-0) is false)</td></tr>
<tr><td>p</td><td>heap pointer compare</td></tr>
<tr><td>L</td><td>lightfunc compare: to be considered equal, Duktape/C function pointers and
                  internal control flags (including the "magic" value) must match</td></tr>
<tr><td>1</td><td>string/buffer vs. number: coerce string with ToNumber() and retry comparison; a buffer is first
                  coerced to string and then to number (e.g. buffer with "2.5" coerces eventually to number 2.5)</td></tr>
<tr><td>2</td><td>boolean vs. any: coerce boolean with ToNumber() and retry comparison</td></tr>
<tr><td>3</td><td>object vs. string/number/buffer: coerce object with ToPrimitive() and retry comparison</td></tr>
</tbody>
</table><h2 class="sectiontitle" id="non-strict-equality-algorithm">Equality (non-strict) <a class="sectionlink" href="#non-strict-equality-algorithm">§</a></h2><p>Non-strict equality comparison is specified in
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">The Abstract Equality Comparison Algorithm</a>
for standard types.  Custom type behavior is as follows:</p><ul>
<li>Buffer: buffer contents are compared byte-by-byte, buffer values containing
    the same byte sequence compare equal.  This comparison is potentially expensive.
    (String comparison also compares contents, but because Duktape uses string
    interning, string content comparison is a cheap pointer compare.  This is
    not the case for buffers.)</li>
<li>Pointer: comparison against any other type returns false.  Comparison to a
    pointer returns true if and only if the pointer values are the same.  Note
    in particular that comparing a number to a pointer returns false.  This seems
    a bit unintuitive, but numbers cannot represent 64-pointers accurately,
    comparing numbers and pointers might be error prone.</li>
<li>Lightfunc: comparison against any other type returns false.  Comparison
    to a lightfunc returns true if and only if both the Duktape/C function
    pointers and internal control flags (including the "magic" value) match.
    Note that a lightfunc never compares equal to an ordinary Function object,
    even when the Function object was created by coercing a lightfunc to an object.</li>
</ul><p>The standard behavior as well as behavior for Duktape custom types is summarized in the table below:</p><table class="typecomparison">
<thead>
<tr><th> </th><th>und</th><th>nul</th><th>boo</th><th>num</th><th>str</th><th>obj</th><th>buf</th><th>ptr</th><th>lfn</th></tr>
</thead>
<tbody>
<tr><th>und</th><td>t  </td><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>nul</th><td> </td><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>boo</th><td> </td><td> </td><td>s  </td><td>2  </td><td>2  </td><td>2  </td><td>2  </td><td>f  </td><td>f  </td></tr>
<tr><th>num</th><td> </td><td> </td><td> </td><td>n  </td><td>1  </td><td>3  </td><td>1  </td><td>f  </td><td>f  </td></tr>
<tr><th>str</th><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>3  </td><td>s  </td><td>f  </td><td>f  </td></tr>
<tr><th>obj</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>p  </td><td>3  </td><td>f  </td><td>f  </td></tr>
<tr><th>buf</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td><td>f  </td></tr>
<tr><th>ptr</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td></tr>
<tr><th>lfn</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>L  </td></tr>
</tbody>
</table><h2 class="sectiontitle" id="strict-equality-algorithm">Strict equality <a class="sectionlink" href="#strict-equality-algorithm">§</a></h2><p>Strict equality is much more straightforward and preferable whenever
possible for simplicity and performance.  It is described in
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6">The Strict Equality Comparison Algorithm</a>
for standard types.  Custom type behavior is as follows:</p><ul>
<li>Buffer: compared as heap pointers.  Buffer contents are not compared,
    so this comparison is always fast.  Note that this behavior is
    inconsistent with string comparison behavior: string contents are
    compared even with strict equality (this is fast, however, due to
    string interning).  This is intentional, as it is important to be
    able to compare buffer values quickly.</li>
<li>Pointer: like non-strict equality.</li>
<li>Lightfunc: like non-strict equality.</li>
</ul><p>The standard behavior as well as behavior for Duktape custom types is summarized in the table below:</p><table class="typecomparison">
<thead>
<tr><th> </th><th>und</th><th>nul</th><th>boo</th><th>num</th><th>str</th><th>obj</th><th>buf</th><th>ptr</th><th>lfn</th></tr>
</thead>
<tbody>
<tr><th>und</th><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>nul</th><td> </td><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>boo</th><td> </td><td> </td><td>s  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>num</th><td> </td><td> </td><td> </td><td>n  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>str</th><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>obj</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>p  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>buf</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>p  </td><td>f  </td><td>f  </td></tr>
<tr><th>ptr</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td></tr>
<tr><th>lfn</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>L  </td></tr>
</tbody>
</table><h2 class="sectiontitle" id="samevalue-algorithm">SameValue <a class="sectionlink" href="#samevalue-algorithm">§</a></h2><p>The <code>SameValue</code> algorithm is not easy to invoke from user code.
It is used by e.g. <code>Object.defineProperty()</code> when checking whether
a property value is about to change.  SameValue is even stricter than a
strict equality comparison, and most notably differs in how numbers are compared.
It is specified in
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.12">The SameValue algorithm</a>
for standard types.  Custom type behavior is as follows:</p><ul>
<li>Buffer: like strict equality.</li>
<li>Pointer: like non-strict (and strict) equality.</li>
<li>Lightfunc: like non-strict (and strict equality).</li>
</ul><p>The standard behavior as well as behavior for Duktape custom types is summarized in the table below:</p><table class="typecomparison">
<thead>
<tr><th> </th><th>und</th><th>nul</th><th>boo</th><th>num</th><th>str</th><th>obj</th><th>buf</th><th>ptr</th><th>lfn</th></tr>
</thead>
<tbody>
<tr><th>und</th><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>nul</th><td> </td><td>t  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>boo</th><td> </td><td> </td><td>s  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>num</th><td> </td><td> </td><td> </td><td>N  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>str</th><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>obj</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>p  </td><td>f  </td><td>f  </td><td>f  </td></tr>
<tr><th>buf</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>p  </td><td>f  </td><td>f  </td></tr>
<tr><th>ptr</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>s  </td><td>f  </td></tr>
<tr><th>lfn</th><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td>L  </td></tr>
</tbody>
</table><h2 class="sectiontitle" id="type-conversion-and-testing">Type conversion and testing <a class="sectionlink" href="#type-conversion-and-testing">§</a></h2><p>The custom types behave as follows for Ecmascript coercions described
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9">Type Conversion and Testing</a>
(except SameValue which was already covered above):</p><table>
<thead>
<tr><th> </th><th>buffer</th><th>pointer</th><th>lightfunc</th></tr>
</thead>
<tbody>
<tr><th>DefaultValue</th><td>TypeError</td><td>TypeError</td><td><code>"light_&lt;PTR&gt;_&lt;FLAGS&gt;"</code> (toString/valueOf)</td></tr>
<tr><th>ToPrimitive</th><td>identity</td><td>identity</td><td><code>
"light_&lt;PTR&gt;_&lt;FLAGS&gt;"</code> (toString/valueOf)</td></tr>
<tr><th>ToBoolean</th><td>false for zero-size buffer, true otherwise</td><td>false for NULL pointer, true otherwise</td><td>true</td></tr>
<tr><th>ToNumber</th><td>like ToNumber() for a string</td><td>0 for NULL pointer, 1 otherwise</td><td>NaN</td></tr>
<tr><th>ToInteger</th><td>same as ToNumber</td><td>same as ToNumber</td><td>0</td></tr>
<tr><th>ToInt32</th><td>same as ToNumber</td><td>same as ToNumber</td><td>0</td></tr>
<tr><th>ToUint32</th><td>same as ToNumber</td><td>same as ToNumber</td><td>0</td></tr>
<tr><th>ToUint16</th><td>same as ToNumber</td><td>same as ToNumber</td><td>0</td></tr>
<tr><th>ToString</th><td>string with bytes from buffer data</td><td><code>sprintf()</code> with <code>%p</code> format (platform specific)</td><td><code>"light_&lt;PTR&gt;_&lt;FLAGS&gt;"</code></td></tr>
<tr><th>ToObject</th><td>Buffer object</td><td>Pointer object</td><td>Function object</td></tr>
<tr><th>CheckObjectCoercible</th><td>allow (no error)</td><td>allow (no error)</td><td>allow (no error)</td></tr>
<tr><th>IsCallable</th><td>false</td><td>false</td><td>true</td></tr>
<tr><th>SameValue</th><td>(covered above)</td><td>(covered above)</td><td>(covered above)</td></tr>
</tbody>
</table><p>When a buffer is string coerced, the bytes from the buffer are used
directly as string data.  The bytes will then be interpreted as CESU-8
(or extended UTF-8) from Ecmascript point of view.</p><p>When a lightfunc is coerced with ToPrimitive() it behaves like an ordinary
function: it gets coerced with <code>Function.prototype.toString()</code> with
the result (normally) being the same as ToString() coercion.</p><p>When a lightfunc is object coerced, a new Function object is created
and the virtual properties (<code>name</code> and <code>length</code> and
the internal "magic" value are copied over to the Function object.</p><h2 class="sectiontitle" id="typealgorithms.6">Custom coercions (ToBuffer, ToPointer) <a class="sectionlink" href="#typealgorithms.6">§</a></h2><p>ToBuffer() coercion is used when a value is forced into a buffer
type e.g. with the <code>duk_to_buffer()</code> API call.  The coercion
is as follows:</p><ul>
<li>A buffer coerces to itself (identity).  The same buffer value is
    returned.</li>
<li>Any other type (including pointer and lightfunc) is first string coerced with
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.8">ToString</a>,
    and the resulting string is then copied, byte-by-byte, into a
    fixed-size buffer.</li>
</ul><p>ToPointer() coercion is used e.g. by the <code>duk_to_pointer()</code>
call.  The coercion is as follows:</p><ul>
<li>A pointer coerces to itself.</li>
<li>Heap-allocated types (string, object, buffer) coerce to a pointer value
    pointing to their <b>internal heap header</b>.  This pointer has only a
    diagnostic value.  Note, in particular, that the pointer returned for a
    buffer or a string <b>does not</b> point to the buffer/string data area.
    (This coercion is likely to change.)</li>
<li>Any other types (including number) coerce to a NULL pointer.</li>
<li>Lightfunc coerces to a NULL pointer.  This is the case because C function
    pointers cannot be coerced to a <code>void *</code> in a portable manner.</li>
</ul><p>The following table summarizes how different types are handled:</p><table>
<thead>
<tr><th> </th><th>ToBuffer</th><th>ToPointer</th></tr>
</thead>
<tbody>
<tr><th>undefined</th><td>buffer with "undefined"</td><td>NULL</td></tr>
<tr><th>null</th><td>buffer with "null"</td><td>NULL</td></tr>
<tr><th>boolean</th><td>buffer with "true" or "false"</td><td>NULL</td></tr>
<tr><th>number</th><td>buffer with string coerced number</td><td>NULL</td></tr>
<tr><th>string</th><td>buffer with copy of string data</td><td>ptr to heap hdr</td></tr>
<tr><th>object</th><td>buffer with ToString(value)</td><td>ptr to heap hdr</td></tr>
<tr><th>buffer</th><td>identity</td><td>ptr to heap hdr</td></tr>
<tr><th>pointer</th><td><code>sprintf()</code> with <code>%p</code> format (platform specific)</td><td>identity</td></tr>
<tr><th>lightfunc</th><td>buffer with ToString(value)</td><td>NULL</td></tr>
</tbody>
</table><div class="note">
There is currently no ToLightFunc() coercion.  Lightfuncs can only be created
using the Duktape C API.
</div><h2 class="sectiontitle" id="typealgorithms.7">Addition <a class="sectionlink" href="#typealgorithms.7">§</a></h2><p>The Ecmascript addition operator is specified in
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1">The Addition operator (+)</a>.
Addition behaves specially if either argument is a string: the other argument
is coerced to a string and the strings are then concatenated.  This behavior
is extended to custom types as follows:</p><ul>
<li>As for standard types, object values are first coerced with <code>ToPrimitive()</code>,
    e.g. a <code>Buffer</code> object is converted to a plain buffer value, and a
    lightfunc value is (normally) coerced with <code>ToString()</code>.</li>
<li>The string concatenation rule is triggered if either argument is a string
    or a buffer.  The arguments are coerced to strings and then concatenated into
    the result string.  This means that adding two buffers currently results in a
    string, not a buffer.</li>
<li>Pointer values fall into the default number addition case.  They are coerced
    with <code>ToNumber()</code> and then added as numbers.  NULL pointers coerce to
    0, non-NULL pointers to 1, so addition results may not be very intuitive.</li>
</ul><h2 class="sectiontitle" id="typealgorithms.8">Property access <a class="sectionlink" href="#typealgorithms.8">§</a></h2><p>If a plain buffer or pointer is used as a property access base value,
properties are looked up from the (initial) built-in prototype object
(<code>Duktape.Buffer.prototype</code> or <code>Duktape.Pointer.prototype</code>).
This mimics the behavior of standard types.</p><p>For example:</p><pre>
duk&gt; buf = Duktape.dec('hex', '414243');  // plain buffer
= ABC
duk&gt; buf.toString;
= function toString() {/* native */}
duk&gt; typeof buf.toString();
= string
</pre><p>Lightfuncs have a few non-configurable and non-writable virtual properties
(<code>name</code> and <code>length</code>) and inherit their remaining
properties from <code>Function.prototype</code>, which allows ordinary inherited
Function methods to be called:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> bound </span><span class="symbol">=</span><span class="normal"> myLightFunc</span><span class="symbol">.</span><span class="function">bind</span><span class="symbol">(</span><span class="string">'dummy'</span><span class="symbol">,</span><span class="normal"> </span><span class="number">123</span><span class="symbol">);</span>
</pre><hr/><h1 class="sectiontitle" id="duktapebuiltins">Duktape built-ins <a class="sectionlink" href="#duktapebuiltins">§</a></h1><p>This section describes Duktape-specific built-in objects, methods, and
values.</p><h2 class="sectiontitle" id="duktapebuiltins.1">Additional global object properties <a class="sectionlink" href="#duktapebuiltins.1">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname"><a href="#builtin-duktape">Duktape</a></td>
<td>The Duktape built-in object.  Contains miscellaneous implementation specific stuff.</td></tr>
<tr><td class="propname"><a href="#virtualization-proxy-object">Proxy</a></td>
<td>Proxy constructor borrowed from ES6 draft (not part of Ecmascript E5/E5.1).</td></tr>
<tr><td class="propname"><a href="#builtin-require">require</a></td>
<td>Non-standard, CommonsJS module loading function.</td></tr>
<tr><td class="propname"><a href="#builtin-print-alert">print</a></td>
<td>Non-standard, browser-like function for writing to <code>stdout</code>.</td></tr>
<tr><td class="propname"><a href="#builtin-print-alert">alert</a></td>
<td>Non-standard, browser-like function for writing to <code>stderr</code>.</td></tr>
</tbody>
</table><h3 class="sectiontitle" id="builtin-require">require() <a class="sectionlink" href="#builtin-require">§</a></h3><p>CommonJS module loading function, see
<a href="#modules">Modules</a>.</p><h3 class="sectiontitle" id="builtin-print-alert">print() and alert() <a class="sectionlink" href="#builtin-print-alert">§</a></h3><p><code>print()</code> writes to <code>stdout</code> with an automatic
flush afterwards.  The bytes written depend on the arguments:</p><ul>
<li>If given a single buffer argument, the contents of that buffer are
    written to <code>stdout</code> as is.  This allows raw byte streams
    to be reliably written.</li>
<li>Otherwise arguments are string coerced, joined with a single space
    character, a newline (0x0a) is appended, and the result is written
    to <code>stdout</code>.  For instance, <code>print('foo', 'bar')</code>
    would write the bytes <code>66 6f 6f 20 62 61 72 0a</code>.  Non-ASCII
    characters are written directly in their internal extended UTF-8
    representation; for most strings this means that output data is
    properly UTF-8 encoded.  Terminal encoding, locale, platform newline
    conventions etc. have no effect on the output.</li>
</ul><p><code>alert()</code> behaves the same way, but writes to
<code>stderr</code>.  Unlike a browser <code>alert()</code>, the call
does not block.</p><h2 class="sectiontitle" id="builtin-duktape">The Duktape object <a class="sectionlink" href="#builtin-duktape">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname"><a href="#builtin-duktape-version">version</a></td>
<td>Duktape version number: <code>(major * 10000) + (minor * 100) + patch</code>.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-env">env</a></td>
<td>Cryptic, version dependent summary of most important effective options like endianness and architecture.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-fin">fin</a></td>
<td>Set or get finalizer of an object.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-enc">enc</a></td>
<td>Encode a value (hex, base-64, JX, JC): <code>Duktape.enc('hex', 'foo')</code>.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-dec">dec</a></td>
<td>Decode a value (hex, base-64, JX, JC): <code>Duktape.dec('base64', 'Zm9v')</code>.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-info">info</a></td>
<td>Get internal information (such as heap address and alloc size) of a value in a version specific format.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-act">act</a></td>
<td>Get information about call stack entry.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-gc">gc</a></td>
<td>Trigger mark-and-sweep garbage collection.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-compact">compact</a></td>
<td>Compact the memory allocated for a value (object).</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-errcreate-errthrow">errCreate</a></td>
<td>Callback to modify/replace a created error.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-errcreate-errthrow">errThrow</a></td>
<td>Callback to modify/replace an error about to be thrown.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-modsearch-modloaded">modSearch</a></td>
<td>Module search function, must be provided by user code if using modules.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-modsearch-modloaded">modLoaded</a></td>
<td>Internal tracking table for loaded modules, maps resolved identifier to exported symbols.</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-buffer">Buffer</a></td>
<td>Buffer constructor (function).</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-pointer">Pointer</a></td>
<td>Pointer constructor (function).</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-thread">Thread</a></td>
<td>Thread constructor (function).</td></tr>
<tr><td class="propname"><a href="#builtin-duktape-logger">Logger</a></td>
<td>Logger constructor (function).</td></tr>
</tbody>
</table><h3 class="sectiontitle" id="builtin-duktape-version">version <a class="sectionlink" href="#builtin-duktape-version">§</a></h3><p>The <code>version</code> property allows version-based feature detection and
behavior.  Version numbers can be compared directly: a logically higher version
will also be numerically higher.  For example:</p><pre class="ecmascript-code"><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> Duktape </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'object'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'not Duktape'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">version </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">10203</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape 1.2.3 or higher'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">version </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">800</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape 0.8.0 or higher (but lower than 1.2.3)'</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Duktape lower than 0.8.0'</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>The value of <code>version</code> for pre-releases is one less than the
actual release, e.g. 1199 for a 0.12.0 pre-release and 10299 for a 1.3.0
pre-release.  See <a href="#versioning">Versioning</a>.</p><p>Remember to check for existence of <code>Duktape</code> when doing feature
detection.  Your code should typically work on as many engines as possible.
Avoid the common pitfall of using a direct identifier reference in the check:</p><pre class="ecmascript-code"><span class="comment">// Bad idea: ReferenceError if missing</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Duktape</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'not Duktape'</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">// Better: check through 'this' (bound to global)</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">Duktape</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'not Duktape'</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">// Better: use typeof to check also type explicitly</span>
<span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> Duktape </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'object'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'not Duktape'</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><h3 class="sectiontitle" id="builtin-duktape-env">env <a class="sectionlink" href="#builtin-duktape-env">§</a></h3><p><code>env</code> summarizes the most important effective compile options
in a version specific, quite cryptic manner.  The format is version specific
and is not intended to be parsed programmatically.  This is mostly useful for
developers (see <code>duk_hthread_builtins.c</code> for the code which sets
the value).</p><p>Example from Duktape 1.1.0:</p><pre class="ecmascript-code"><span class="normal">ll u n p2 a4 x64 linux gcc     </span><span class="comment">// l|b|m integer endianness, l|b|m IEEE double endianness</span>
<span class="normal">                               </span><span class="comment">// p|u packed/unpacked tval</span>
<span class="normal">                               </span><span class="comment">// n|various, memory optimization options (n = none)</span>
<span class="normal">                               </span><span class="comment">// p1|p2|p3 prop memory layout</span>
<span class="normal">                               </span><span class="comment">// a1|a4|a8: align target</span>
<span class="normal">                               </span><span class="comment">// x64|x86|arm|etc: architecture</span>
<span class="normal">                               </span><span class="comment">// linux|windows|etc: operating system</span>
<span class="normal">                               </span><span class="comment">// gcc|clang|msvc|etc: compiler</span>
</pre><h3 class="sectiontitle" id="builtin-duktape-fin">fin() <a class="sectionlink" href="#builtin-duktape-fin">§</a></h3><p>When called with a single argument, gets the current finalizer of an object:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> currFin </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">o</span><span class="symbol">);</span>
</pre><p>When called with two arguments, sets the finalizer of an object (returns undefined):</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">o</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="string">'finalizer called'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">o</span><span class="symbol">,</span><span class="normal"> undefined</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// disable</span>
</pre><h3 class="sectiontitle" id="builtin-duktape-enc">enc() <a class="sectionlink" href="#builtin-duktape-enc">§</a></h3><p><code>enc()</code> encodes its argument value into chosen format.
The first argument is a format (currently supported are "hex", "base64",
"jx" and "jc"), second argument is the value to encode, and any further
arguments are format specific.</p><p>For "hex" and "base64", buffer values are encoded as is, other values
are string coerced and the internal byte representation (extended UTF-8)
is then encoded.  The result is a string.  For example, to encode a string
into base64:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">enc</span><span class="symbol">(</span><span class="string">'base64'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'foo'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'Zm9v'</span>
</pre><p>For "jx" and "jc" the argument list following the format name is the
same as for <code>JSON.stringify()</code>: value, replacer (optional),
space (optional).  For example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">enc</span><span class="symbol">(</span><span class="string">'jx'</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="number">123</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">,</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints JX encoded {foo:123} with 4-space indent</span>
</pre><h3 class="sectiontitle" id="builtin-duktape-dec">dec() <a class="sectionlink" href="#builtin-duktape-dec">§</a></h3><p><code>dec()</code> provides the reverse function of <code>enc()</code>.</p><p>For "hex" and "base64" the input value is first string coerced (it only
really makes sense to decode strings).  The result is always a buffer.  For example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'base64'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'Zm9v'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> result</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'buffer foo'</span>
</pre><p>If you wish to get back a string value, you can simply:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> </span><span class="function">String</span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'base64'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'Zm9v'</span><span class="symbol">));</span>
<span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> result</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'string foo'</span>
</pre><p>For "jx" and "jc" the argument list following the format name is the same
as for <code>JSON.parse()</code>: text, reviver (optional).  For example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'jx'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"{foo:123}"</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 123</span>
</pre><h3 class="sectiontitle" id="builtin-duktape-info">info() <a class="sectionlink" href="#builtin-duktape-info">§</a></h3><p>When given an arbitrary input value, <code>Duktape.info()</code> returns an
array of values with internal information related to the value.  The format of
of the values in the array is version specific.  This is mainly useful for
debugging and diagnosis, e.g. when estimating rough memory usage of objects.</p><p>The current result array format is described in the table below.  Notes:</p><ul>
<li>Memory sizes do not include any heap overhead (which may be 8-16 bytes or
    more, depending on what kind of allocation algorithm is used).</li>
<li>Reference counts are not adjusted in any way, and include references to
    the value caused by the <code>info()</code> call.</li>
<li>"type tag" is a number matching <code>DUK_TYPE_xxx</code> from <code>duktape.h</code>.</li>
<li>Prop entry count: for objects, number of entries allocated for properties
    outside the array part.</li>
<li>Prop entry next: for objects, index where the next new property will be
    inserted within the entry part.  When "prop entry count" equals "prop entry next",
    insertion of a new property causes an object resize.
    Note that this number does <i>not</i> indicate the number of properties actually
    present in the object because some entries may have been deleted and not yet
    "compacted".</li>
<li>Prop array count: for objects, number of entries currently allocated
    for the array part (if any); there is no value to indicate the number
    of actually used entries (indices present).</li>
<li>Prop hash count: for objects, size of entry part hash lookup table or
    zero if not present.  Typical small objects don't have a hash part.</li>
<li>Function data contains bytecode instructions, constants, etc.  It is
    shared between all instances (closures) of a certain function template.</li>
<li>Internal type tag values may change between versions and are also
    dependent on the memory layout used for tagged values internally.</li>
</ul><div class="table-wrap">
<table>
<thead>
<tr><th>Type</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>null</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>boolean</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>number</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>string</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>object, Ecmascript function</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>prop alloc size</td>
<td>prop entry count</td>
<td>prop entry next</td>
<td>prop array count</td>
<td>prop hash count</td>
<td>func data size</td>
</tr>
<tr>
<td>object, Duktape/C function</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>prop alloc size</td>
<td>prop entry count</td>
<td>prop entry next</td>
<td>prop array count</td>
<td>prop hash count</td>
<td>-</td>
</tr>
<tr>
<td>object, thread</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>prop alloc size</td>
<td>prop entry count</td>
<td>prop entry next</td>
<td>prop array count</td>
<td>prop hash count</td>
<td>-</td>
</tr>
<tr>
<td>object, other</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>prop alloc size</td>
<td>prop entry count</td>
<td>prop entry next</td>
<td>prop array count</td>
<td>prop hash count</td>
<td>-</td>
</tr>
<tr>
<td>buffer, fixed</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>buffer, dynamic</td>
<td>type tag</td>
<td>heap ptr</td>
<td>refcount</td>
<td>heap hdr size</td>
<td>curr buf size</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>pointer</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>lightfunc</td>
<td>type tag</td>
<td>internal type tag</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div><h3 class="sectiontitle" id="builtin-duktape-act">act() <a class="sectionlink" href="#builtin-duktape-act">§</a></h3><p>Get information about a call stack entry.  Takes a single number argument
indicating depth in the call stack: -1 is the top entry, -2 is the one below
that etc.  Returns an object describing the call stack entry, or <code>undefined</code>
if the entry doesn't exist.  Example:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">dump</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">--)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        t </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">act</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lineNumber</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="keyword">function</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">,</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">enc</span><span class="symbol">(</span><span class="string">'jx'</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="function">dump</span><span class="symbol">();</span>
</pre><p>The example, when executed with the command line tool, currently prints
something like:</p><pre>
-1 0 act {lineNumber:0,pc:0,function:{_func:true}}
-2 4 dump {lineNumber:4,pc:16,function:{_func:true}}
-3 10 global {lineNumber:10,pc:5,function:{_func:true}}
</pre><p>The interesting entries are <code>lineNumber</code> and <code>function</code>
which provides e.g. the function name.</p><p>You can also implement a helper to get the current line number using
<code>Duktape.act()</code>:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">getCurrentLine</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="string">'use duk notail'</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/* Tail calls are prevented to ensure calling activation exists.</span>
<span class="comment">     * Call stack indices: -1 = Duktape.act, -2 = getCurrentLine, -3 = caller</span>
<span class="comment">     */</span>

<span class="normal">    </span><span class="keyword">var</span><span class="normal"> a </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">act</span><span class="symbol">(-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="cbracket">{}</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">lineNumber</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'running on line:'</span><span class="symbol">,</span><span class="normal"> </span><span class="function">getCurrentLine</span><span class="symbol">());</span>
</pre><div class="note">
The properties provided for call stack entries may change between versions.
</div><h3 class="sectiontitle" id="builtin-duktape-gc">gc() <a class="sectionlink" href="#builtin-duktape-gc">§</a></h3><p>Trigger a forced mark-and-sweep collection.  If mark-and-sweep is disabled,
this call is a no-op.</p><!-- Return value is undocumented for now, which is probably good for now.
     Not sure what the best return value would be.
--><h3 class="sectiontitle" id="builtin-duktape-compact">compact() <a class="sectionlink" href="#builtin-duktape-compact">§</a></h3><p>Minimize the memory allocated for a target object.  Same as the C API call
<code>duk_compact()</code> but accessible from Ecmascript code.  If called with
a non-object argument, this call is a no-op.  The argument value is returned by
the function, which allows code such as:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    foo</span><span class="symbol">:</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">compact</span><span class="symbol">(</span><span class="cbracket">{</span><span class="normal"> bar</span><span class="symbol">:</span><span class="number">123</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">)</span>
<span class="cbracket">}</span>
</pre><p>This call is useful when you know that an object is unlikely to gain new
properties, but you don't want to seal or freeze the object in case it does.</p><h3 class="sectiontitle" id="builtin-duktape-errcreate-errthrow">errCreate() and errThrow() <a class="sectionlink" href="#builtin-duktape-errcreate-errthrow">§</a></h3><p>These can be set by user code to process/replace errors when they are created
(<code>errCreate</code>) or thrown (<code>errThrow</code>).  Both values are
initially non-existent.</p><p>See
<a href="#error-handlers">Error handlers (errCreate and errThrow)</a> for
details.</p><h3 class="sectiontitle" id="builtin-duktape-modsearch-modloaded">modSearch() and modLoaded <a class="sectionlink" href="#builtin-duktape-modsearch-modloaded">§</a></h3><p><code>modSearch()</code> is a module search function which must be provided
by user code to support module loading.
<code>modLoaded</code> is an internal module loading tracking table
maintained by Duktape which maps a resolved absolute module identifier to the
module's <code>exports</code> object for modules which are either fully loaded
or currently being loaded.</p><p>See <a href="#modules">Modules</a> for details.</p><h2 class="sectiontitle" id="builtin-duktape-buffer">Duktape.Buffer (constructor) <a class="sectionlink" href="#builtin-duktape-buffer">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">prototype</td><td>Prototype for Buffer objects.</td></tr>
</tbody>
</table><p>The Buffer constructor is a function which returns a plain buffer when
called as a normal function and a Buffer object when called as a
constructor.  Otherwise the behavior is the same:</p><ul>
<li>If the first argument is a plain buffer, the buffer is used as is (a new
    buffer is not created).  The second argument is ignored.  This form
    can be used to wrap a plain buffer value into a Buffer object.</li>
<li>If the first argument is a Buffer object, the internal plain buffer value
    of the argument is used (a new buffer is not created).  The second argument
    is again ignored.  If called as a constructor, a new Buffer object is
    returned, but it will internally point to the same plain buffer value.</li>
<li>If the first argument is a string, a new buffer is created and the bytes
    from the string's internal extended UTF-8 representation are copied to the
    buffer.  The second argument (if present) indicates whether or not the new
    buffer should be dynamic (resizable); the default value is false.</li>
<li>If the first argument is a number, a new buffer is created and filled with
    zero.  The second argument (if present) indicates whether or not the new
    buffer should be dynamic.  Zero filling the buffer is the default behavior,
    but this can be disabled with a feature option; if disabled, the contents
    will be unpredictable.</li>
<li>When called as a constructor, the result is converted into a Buffer
    object whose internal value is the plain buffer.  The internal prototype
    of the newly created Buffer will be the
    <code>Duktape.Buffer.prototype</code> object.</li>
</ul><div class="note">
There is currently (in Duktape 0.10.0) no way direct way to create a copy of
a buffer (i.e. a new buffer with the same contents but a separate underlying
buffer).  This will be added in Duktape 0.11.0; for now you can make a copy
inefficiently e.g. as <code>Duktape.Buffer(String(orig_buf))</code>.  Buffers
are currently mostly intended to be operated with from C code.
</div><h2 class="sectiontitle" id="duktapebuiltins.4">Duktape.Buffer.prototype <a class="sectionlink" href="#duktapebuiltins.4">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">toString</td><td>Convert Buffer to a printable string.</td></tr>
<tr><td class="propname">valueOf</td><td>Return the primitive buffer value held by Buffer.</td></tr>
</tbody>
</table><p><code>toString()</code> and <code>valueOf</code> accept both plain buffers and
Buffer objects as their <code>this</code> binding.  This allows code such as:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> plain_buf </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Buffer</span><span class="symbol">(</span><span class="string">'test'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">plain_buf</span><span class="symbol">.</span><span class="function">toString</span><span class="symbol">());</span>
</pre><h2 class="sectiontitle" id="builtin-duktape-pointer">Duktape.Pointer (constructor) <a class="sectionlink" href="#builtin-duktape-pointer">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">prototype</td><td>Prototype for Pointer objects.</td></tr>
</tbody>
</table><p>The Pointer constructor is a function which can be called both as an
ordinary function and as a constructor:</p><ul>
<li>When called as a function, coerces the first argument to a pointer using
    the custom <code>ToPointer</code> coercion.  The return value is a plain
    pointer (not a Pointer object).</li>
<li>When called as a constructor, coerces the first argument to a pointer
    using the custom <code>ToPointer</code> coercion.  Returns a Pointer object
    whose internal value is the pointer resulting from the coercion.  The
    internal prototype of the newly created Pointer will be the
    <code>Duktape.Pointer.prototype</code> object.</li>
</ul><h2 class="sectiontitle" id="duktapebuiltins.6">Duktape.Pointer.prototype <a class="sectionlink" href="#duktapebuiltins.6">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">toString</td><td>Convert Pointer to a printable string.</td></tr>
<tr><td class="propname">valueOf</td><td>Return the primitive pointer value held by Pointer.</td></tr>
</tbody>
</table><p><code>toString()</code> and <code>valueOf</code> accept both plain pointers and
Pointer objects as their <code>this</code> binding.  This allows code such as:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> plain_ptr </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Pointer</span><span class="symbol">(</span><span class="cbracket">{</span><span class="normal"> test</span><span class="symbol">:</span><span class="normal"> </span><span class="string">'object'</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">plain_ptr</span><span class="symbol">.</span><span class="function">toString</span><span class="symbol">());</span>
</pre><h2 class="sectiontitle" id="builtin-duktape-thread">Duktape.Thread (constructor) <a class="sectionlink" href="#builtin-duktape-thread">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">prototype</td><td>Prototype for Thread objects.</td></tr>
<tr><td class="propname">resume</td><td>Resume target thread with a value or an error.
Arguments: target thread, value, flag indicating whether value is to be thrown (optional, default false).</td></tr>
<tr><td class="propname">yield</td><td>Yield a value or an error from current thread.
Arguments: value, flag indicating whether value is to be thrown (optional, default false).</td></tr>
<tr><td class="propname">current</td><td>Get currently running Thread object.</td></tr>
</tbody>
</table><p>The Thread constructor is a function which can be called both as an
ordinary function and as a constructor.  The behavior is the same in both
cases:</p><ul>
<li>The first argument is checked to be a function (if not, a <code>TypeError</code>
    is thrown).  The return value is a new thread whose initial function is
    recorded to be the argument function (this function will start executing
    when the new thread is first resumed).  The internal prototype of the
    newly created Thread will be the <code>Duktape.Thread.prototype</code> object.</li>
</ul><h2 class="sectiontitle" id="duktapebuiltins.8">Duktape.Thread.prototype <a class="sectionlink" href="#duktapebuiltins.8">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td colspan="2">No properties at the moment.</td></tr>
</tbody>
</table><h2 class="sectiontitle" id="builtin-duktape-logger">Duktape.Logger (constructor) <a class="sectionlink" href="#builtin-duktape-logger">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">prototype</td><td>Prototype for Logger objects.</td></tr>
<tr><td class="propname">clog</td><td>Representative logger for log entries written from C code.</td></tr>
</tbody>
</table><p>Called as a constructor, creates a new Logger object with a specified name
(first argument).  If the name is omitted, Logger will automatically assign
a name based on the calling function's <code>fileName</code>.
If called as a normal function, throws a <code>TypeError</code>.</p><p>Logger instances have the following properties:</p><ul>
<li><code>n</code>: logger name; the property will be missing if (a) the given
    name is not a string, or (b) no name is given and the automatic assignment
    fails.  The logger will then inherit a value from the Logger prototype.
    You can manually set this property later to whatever value is desired.</li>
<li><code>l</code>: log level, indicates the minimum log level to output.
    This property is not assigned by default and the logger inherits a default
    level from the Logger prototype.  You can manually set this property to
    another value to control log level on a per-logger basis.</li>
</ul><p>See <a href="#logging">Logging</a> on how to use loggers.</p><h2 class="sectiontitle" id="duktapebuiltins.10">Duktape.Logger.prototype <a class="sectionlink" href="#duktapebuiltins.10">§</a></h2><table>
<thead>
<tr>
<th>Property</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td class="propname">raw</td><td>Output a formatted log line (buffer value), by default writes to <code>stderr</code>.</td></tr>
<tr><td class="propname">fmt</td><td>Format a single (object) argument.</td></tr>
<tr><td class="propname">trace</td><td>Write a trace level (level 0, TRC) log entry.</td></tr>
<tr><td class="propname">debug</td><td>Write a debug level (level 1, DBG) log entry.</td></tr>
<tr><td class="propname">info</td><td>Write an info level (level 2, INF) log entry.</td></tr>
<tr><td class="propname">warn</td><td>Write a warn level (level 3, WRN) log entry.</td></tr>
<tr><td class="propname">error</td><td>Write an error level (level 4, ERR) log entry.</td></tr>
<tr><td class="propname">fatal</td><td>Write a fatal level (level 5, FTL) log entry.</td></tr>
<tr><td class="propname">l</td><td>Default log level, initial value is 2 (info).</td></tr>
<tr><td class="propname">n</td><td>Default logger name, initial value is "anon".</td></tr>
</tbody>
</table><hr/><h1 class="sectiontitle" id="es6features">Ecmascript E6 features <a class="sectionlink" href="#es6features">§</a></h1><p>This section describes the small set of features Duktape borrows from the
<a href="https://people.mozilla.org/~jorendorff/es6-draft.html">current ES6 draft</a>
("Version: Rev 24, April 27, 2014 Draft").  These features are not fully compliant;
the intent is to minimize custom features and to align with the coming ES6 specification.</p><h2 class="sectiontitle" id="es6-proto">Object.setPrototypeOf and Object.prototype.__proto__ <a class="sectionlink" href="#es6-proto">§</a></h2><p><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.setprototypeof">Object.setPrototypeOf</a>
allows user to set the internal prototype of an object which is not supported in
Ecmascript E5.  The Ecmascript E6 draft also provides
<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.__proto__">Object.prototype.__proto__</a>,
an accessor property (setter/getter) which provides the same functionality
but is compatible with existing code base which has relied on a non-standard
<code>__proto__</code> property for a while.  Duktape does not support the
<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-__proto___-property-names-in-object-initializers">__proto__ property name in an object initializer</a>.</p><p>These custom features can be disabled with the feature options
<code>DUK_OPT_NO_ES6_OBJECT_SETPROTOTYPEOF</code> and
<code>DUK_OPT_NO_ES6_OBJECT_PROTO_PROPERTY</code>.</p><h2 class="sectiontitle" id="es6-proxy">Proxy object (subset) <a class="sectionlink" href="#es6-proxy">§</a></h2><p>The Ecmascript E6 <code>Proxy</code> object allows property virtualization
and fine-grained access control for accessing an underlying plain object.
Duktape implements a strict subset of the <code>Proxy</code> object from the
ES6 draft (Rev 24).  The following traps are implemented:</p><table>
<thead>
<tr><th>Trap</th><th>Implemented</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td class="propname">getPrototypeOf</td><td>no</td><td></td></tr>
<tr><td class="propname">setPrototypeOf</td><td>no</td><td></td></tr>
<tr><td class="propname">isExtensible</td><td>no</td><td></td></tr>
<tr><td class="propname">preventExtension</td><td>no</td><td></td></tr>
<tr><td class="propname">getOwnPropertyDescriptor</td><td>no</td><td></td></tr>
<tr><td class="propname">defineProperty</td><td>no</td><td></td></tr>
<tr><td class="propname">has</td><td>yes</td><td><code>Object.hasOwnProperty()</code> does not invoke the trap at the moment, <code>key in obj</code> does</td></tr>
<tr><td class="propname">get</td><td>yes</td><td></td></tr>
<tr><td class="propname">set</td><td>yes</td><td></td></tr>
<tr><td class="propname">deleteProperty</td><td>yes</td><td></td></tr>
<tr><td class="propname">enumerate</td><td>yes</td><td></td></tr>
<tr><td class="propname">ownKeys</td><td>yes</td><td><code>Object.keys()</code> enumerability check limitation</td></tr>
<tr><td class="propname">apply</td><td>no</td><td></td></tr>
<tr><td class="propname">construct</td><td>no</td><td></td></tr>
</tbody>
</table><p>Limitations include:</p><ul>
<li>Only about half of the ES6 traps have been implemented.  This causes odd behavior
    if you e.g. call <code>Object.defineProperty()</code> on a proxy object.</li>
<li><code>Object.keys()</code> invokes the <code>ownKeys</code> trap, cleans up the trap
    result to a gap-free string list, but does not check that the property names returned
    by the trap are enumerable.  <code>Object.keys()</code> and <code>Object.getOwnPropertyNames()</code>
    thus currently return the same value for a proxy object implementing the <code>ownKeys</code>
    trap.</li>
<li>Proxy revocation feature of ES6 draft is not supported.</li>
<li>The target and handler objects given to <code>new Proxy()</code> cannot
    be proxy objects themselves.  ES6 poses no such limitation, but Duktape
    enforces it to simplify the internal implementation.</li>
<li>As ES6 is still in a draft phase so the subset implemented by Duktape
    may not be forwards compatible.</li>
</ul><p>This custom feature can be disabled with the feature option
<code>DUK_OPT_NO_ES6_PROXY</code>.</p><hr/><h1 class="sectiontitle" id="custombehavior">Custom behavior <a class="sectionlink" href="#custombehavior">§</a></h1><p>This section summarizes Duktape behavior which deviates from the E5.1
specification.</p><h2 class="sectiontitle" id="custombehavior.1">Duktape built-in and custom types <a class="sectionlink" href="#custombehavior.1">§</a></h2><p>The <code>Duktape</code> built-in is (of course) non-standard and provides
access to Duktape specific features.  Also the buffer, pointer, and lightfunc
types are custom.</p><h2 class="sectiontitle" id="custombehavior.2">Internal properties <a class="sectionlink" href="#custombehavior.2">§</a></h2><p>Objects may have <a href="#internalproperties">internal properties</a> which
are essentially hidden from normal code: they won't be enumerated or returned
even by e.g. <code>Object.getOwnPropertyNames()</code>.  Ordinary Ecmascript
code cannot refer to such properties because the property keys intentionally
use invalid UTF-8 (<code>0xFF</code> prefix byte).</p><h2 class="sectiontitle" id="custombehavior.3">"use duk notail" directive <a class="sectionlink" href="#custombehavior.3">§</a></h2><p>The <a href="#use-duk-notail">"use duk notail"</a> directive is non-standard.
It prevents a function from being tail called.</p><h2 class="sectiontitle" id="custombehavior.4">The global require() function for module loading <a class="sectionlink" href="#custombehavior.4">§</a></h2><p>The <code>require()</code> built-in is non-standard, and provided for
CommonJS-based module loading, see <a href="#modules">Modules</a>.</p><h2 class="sectiontitle" id="custombehavior.5">Additional Error and Function object properties <a class="sectionlink" href="#custombehavior.5">§</a></h2><p>See
<a href="#errorobjects">Error objects</a> and
<a href="functionobjects">Function objects</a>.</p><p>Non-strict function instances don't have a <code>caller</code> property in the
E5/E5.1 specification.  Some real world code expects to have this property, so it
can be enabled with the feature option <code>DUK_OPT_NONSTD_FUNC_CALLER_PROPERTY</code>.</p><h2 class="sectiontitle" id="custombehavior.6">Function statements <a class="sectionlink" href="#custombehavior.6">§</a></h2><p>E5.1 does not allow a function declaration to appear outside program or
function top level:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">test</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// point A</span>
<span class="normal">    </span><span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Error</span><span class="symbol">(</span><span class="string">'test'</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// This is a SyntaxError in E5.1</span>
<span class="normal">        </span><span class="keyword">function</span><span class="normal"> </span><span class="function">func</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> e</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="comment">// point B</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">// point C</span>
<span class="cbracket">}</span>
</pre><p>These declarations are also referred to as "function statements", and appear
quite often in real world code (including the test262 test suite), so they are
allowed by Duktape.  Unfortunately there are several semantics used by different
Javascript engines.  Duktape follows the V8 behavior for function statements:</p><ul>
<li>Strict function: a SyntaxError is thrown (standard behavior).</li>
<li>Non-strict function: treat a function statement like an ordinary function
    declaration, conceptually "hoisting" it to the top of the function.</li>
</ul><p>As an illustration, the above example would behave as the following:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">test</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">function</span><span class="normal"> </span><span class="function">func</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> e</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal"> </span>
<span class="normal">    </span><span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Error</span><span class="symbol">(</span><span class="string">'test'</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
</pre><p><code>func()</code> in the above example would already be declared
and callable in point A, and would not have access to the <code>e</code>
binding in any of the points A, B, or C.</p><h2 class="sectiontitle" id="custombehavior.7">RegExp leniency <a class="sectionlink" href="#custombehavior.7">§</a></h2><p>Although not allowed by E5.1, the following escape is allowed in RegExp
syntax:</p><pre>
  /\$/       /* matches dollar literally, non-standard */
  /\u0024/   /* same, standard */
</pre><p>This escape occurs in real world code so it is allowed.  (More leniency
will be added in future versions to deal with real world RegExps; dollar
escapes are not the only issue.)</p><h2 class="sectiontitle" id="custombehavior.8">Array.prototype.splice() when deleteCount not given <a class="sectionlink" href="#custombehavior.8">§</a></h2><p>When deleteCount (the 2nd argument) is not given to <code>Array.prototype.splice()</code>,
the standard behavior is to work as if the 2nd argument was <code>undefined</code>
(or 0, which has the same behavior after coercions).  A more real world compatible
behavior is to treat the missing argument like positive infinity, i.e. to extend
the splice operation to the end of the array.</p><p>Because the non-standard real world behavior is expected by much existing code,
Duktape uses this behavior by default.  The strict standards compliant behavior can
be enabled with the feature option <code>DUK_OPT_NO_NONSTD_ARRAY_SPLICE_DELCOUNT</code>.</p><h2 class="sectiontitle" id="custombehavior.9">Array.prototype.concat() trailing non-existent elements <a class="sectionlink" href="#custombehavior.9">§</a></h2><p>When the result of an array <code>concat()</code> would have trailing non-existent
elements, the standard behavior is to ignore them so that they are not reflected in
the result <code>length</code>.  Real world behavior is to include them in the result
value <code>length</code>.  See
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-bi-array-proto-concat-nonstd-trailing.js">test-bi-array-proto-concat-nonstd-trailing.js</a>.</p><p>The real world behavior seems consistent in other engines (V8, Rhino, Spidermonkey
at least), so Duktape uses the real world behavior by default.  The strict standards compliant
behavior can be enabled with the feature option <code>DUK_OPT_NO_NONSTD_ARRAY_CONCAT_TRAILER</code>.</p><h2 class="sectiontitle" id="custombehavior.10">Array.prototype.map() trailing non-existent elements <a class="sectionlink" href="#custombehavior.10">§</a></h2><p>Similar issue as with <code>Array.prototype.concat()</code>, see
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-bi-array-proto-map-nonstd-trailing.js">test-bi-array-proto-map-nonstd-trailing.js</a>.  The strict standards compliant behavior can be
enabled with the feature option <code>DUK_OPT_NO_NONSTD_ARRAY_MAP_TRAILER</code>.</p><h2 class="sectiontitle" id="custombehavior.11">Setter/getter key argument <a class="sectionlink" href="#custombehavior.11">§</a></h2><p>Ecmascript standard behavior is that setters and getters are not given
the name of the property being accessed.  This prevents reusing a single
setter or a getter for multiple properties; separate functions are needed
for each property which is sometimes inconvenient and wastes memory.</p><p>Duktape provides the property key name as a non-standard additional
argument to setter and getter functions.  See
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-dev-nonstd-setget-key-argument.js">test-dev-nonstd-setget-key-argument.js</a>
and <a href="#propertyvirtualization">Property virtualization</a>
for more discussion.  The strict standards compliant behavior can be enabled
with the feature option <code>DUK_OPT_NO_NONSTD_ACCESSOR_KEY_ARGUMENT</code>.</p><h2 class="sectiontitle" id="custombehavior.12">Object.setPrototypeOf and Object.prototype.__proto__ (ES6 draft) <a class="sectionlink" href="#custombehavior.12">§</a></h2><p>See <a href="#es6-proto">Object.setPrototypeOf and Object.prototype.__proto__</a>.</p><h2 class="sectiontitle" id="custombehavior.13">Proxy object (ES6 draft subset) <a class="sectionlink" href="#custombehavior.13">§</a></h2><p>See <a href="#es6-proxy">Proxy object (subset)</a>.</p><h2 class="sectiontitle" id="custombehavior.14">JSON.stringify() escapes U+2028 and U+2029 <a class="sectionlink" href="#custombehavior.14">§</a></h2><p><code>JSON.stringify()</code> standard behavior is to output U+2028 and
U+2029 without escaping.  This leads to counterintuitive behavior when the
output is used in a web page or parsed with <code>eval()</code>: the U+2028
and U+2029 characters are considered line terminators which leads to a syntax
error (unterminated string).  Duktape escapes U+2028 and U+2029 by default
to avoid this issue; you can turn on the compliant behavior with the feature
option <code>DUK_OPT_NO_NONSTD_JSON_ESC_U2028_U2029</code>.</p><h2 class="sectiontitle" id="custombehavior.15">String.fromCharCode() accepts 32-bit codepoints <a class="sectionlink" href="#custombehavior.15">§</a></h2><p><code>String.fromCharCode()</code> standard behavior is to use ToUInt16()
coercion for codepoint values.  Duktape uses ToUint32() by default to better
support non-BMP strings.  You can force the compliant behavior with the
feature option <code>DUK_OPT_NO_NONSTD_STRING_FROMCHARCODE_32BIT</code>.</p><h2 class="sectiontitle" id="custombehavior.16">Array instance numeric index writes <a class="sectionlink" href="#custombehavior.16">§</a></h2><p>By default Duktape provides a fast path for writing to Array instances.
The fast path is active when numeric indices are used (e.g. <code>arr[7] = 'foo'</code>)
and a few internal conditions are met.  When the fast path is taken, Duktape
doesn't check Array.prototype for conflicting properties (these are very rare in
practical code), which makes common array writes faster.  The behavior is
non-compliant, but there's no outward difference unless Array.prototype has
properties with numeric keys.  You can turn on the compliant behavior with
the feature option <code>DUK_OPT_NO_NONSTD_ARRAY_WRITE</code>.  See the
following for more details on the fast path behavior:
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-misc-array-fast-write.js">test-misc-array-fast-write.js</a>.</p><hr/><h1 class="sectiontitle" id="customjson">Custom JSON formats <a class="sectionlink" href="#customjson">§</a></h1><h2 class="sectiontitle" id="customjson.1">Ecmascript JSON shortcomings <a class="sectionlink" href="#customjson.1">§</a></h2><p>The standard JSON format has a number of shortcomings when used with
Ecmascript:</p><ul>
<li><code>undefined</code> and function values are not supported</li>
<li>NaN and infinity values are not supported</li>
<li>Duktape custom types are, of course, not supported</li>
<li>Codepoints above BMP cannot be represented except as surrogate pairs</li>
<li>Codepoints above U+10FFFF cannot be represented even as surrogate pairs</li>
<li>The output is not printable ASCII which is often inconvenient</li>
</ul><p>These limitations are part of the Ecmascript specification which
explicitly prohibits more lenient behavior.  Duktape provides two more
programmer friendly custom JSON format variants: <b>JX</b> and <b>JC</b>,
described below.</p><h2 class="sectiontitle" id="customjson.2">Custom JX format <a class="sectionlink" href="#customjson.2">§</a></h2><p>JX encodes all values in a very readable manner and parses back
almost all values in a faithful manner (function values being the most
important exception).  Output is pure printable ASCII, codepoints above
U+FFFF are encoded with a custom escape format, and quotes around object
keys are omitted in most cases.  JX is not JSON compatible but a very
readable format, most suitable for debugging, logging, etc.</p><p>JX is used as follows:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">/</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> bar</span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">[</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span><span class="normal"> undefined</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="function">enc</span><span class="symbol">(</span><span class="string">'jx'</span><span class="symbol">,</span><span class="normal"> obj</span><span class="symbol">));</span>
<span class="comment">// prints out: {foo:NaN,bar:[1,undefined,3]}</span>

<span class="keyword">var</span><span class="normal"> dec </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'jx'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'{ foo: 123, bar: undefined, quux: NaN }'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">dec</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">,</span><span class="normal"> dec</span><span class="symbol">.</span><span class="normal">bar</span><span class="symbol">,</span><span class="normal"> dec</span><span class="symbol">.</span><span class="normal">quux</span><span class="symbol">);</span>
<span class="comment">// prints out: 123 undefined NaN</span>
</pre><h2 class="sectiontitle" id="customjson.3">Custom JC format <a class="sectionlink" href="#customjson.3">§</a></h2><p>JC encodes all values into standard JSON.  Values not supported by
standard JSON are encoded as objects with a marker key beginning with an
underscore (e.g. <code>{"_ptr":"0xdeadbeef"}</code>).  Such values parse
back as ordinary objects.  However, you can revive them manually more or
less reliably.  Output is pure printable ASCII; codepoints above U+FFFF
are encoded as plain string data with the format "U+nnnnnnnn"
(e.g. <code>U+0010fedc</code>).</p><p>JC is used as follows:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">/</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> bar</span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">[</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span><span class="normal"> undefined</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">Duktape</span><span class="symbol">.</span><span class="function">enc</span><span class="symbol">(</span><span class="string">'jc'</span><span class="symbol">,</span><span class="normal"> obj</span><span class="symbol">));</span>
<span class="comment">// prints out: {"foo":{"_nan":true},"bar":[1,{"_undef":true},3]}</span>

<span class="keyword">var</span><span class="normal"> dec </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'jc'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'{ "foo": 123, "bar": {"_undef":true}, "quux": {"_nan":true} }'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">dec</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">,</span><span class="normal"> dec</span><span class="symbol">.</span><span class="normal">bar</span><span class="symbol">,</span><span class="normal"> dec</span><span class="symbol">.</span><span class="normal">quux</span><span class="symbol">);</span>
<span class="comment">// prints out: 123 [object Object] [object Object]</span>
</pre><p>The JC decoder is essentially the same as the standard JSON decoder
at the moment: all JC outputs are valid JSON and no custom syntax is needed.
As shown in the example, custom values (like <code>{"_undef":true}</code>)
are <b>not</b> revived automatically.  They parse back as ordinary objects
instead.</p><h2 class="sectiontitle" id="customjson.4">Codepoints above U+FFFF and invalid UTF-8 data <a class="sectionlink" href="#customjson.4">§</a></h2><p>All standard Ecmascript strings are valid CESU-8 data internally, so
behavior for codepoints above U+FFFF never poses compliance issues.  However,
Duktape strings may contain <a href="#extended-utf8">extended UTF-8</a>
codepoints and may even contain invalid UTF-8 data.</p><p>The Duktape JSON implementation, including the standard Ecmascript JSON API,
use replacement characters to deal with invalid UTF-8 data.  The resulting
string may look a bit odd, but this behavior is preferable to throwing an
error.</p><h2 class="sectiontitle" id="customjson.5">JSON format examples <a class="sectionlink" href="#customjson.5">§</a></h2><p>The table below summarizes how different values encode in each
encoding:</p><table>
<thead>
<tr>
<th>Value</th>
<th>Standard JSON</th>
<th>JX</th>
<th>JC</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>n/a</td>
<td><code>undefined</code></td>
<td><code>{"_undef":true}</code></td>
<td>Standard JSON: encoded as <code>null</code> inside arrays, otherwise omitted</td>
</tr>
<tr>
<td>null</td>
<td><code>null</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
<td>standard JSON</td>
</tr>
<tr>
<td>true</td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td>standard JSON</td>
</tr>
<tr>
<td>false</td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td>standard JSON</td>
</tr>
<tr>
<td>123.4</td>
<td><code>123.4</code></td>
<td><code>123.4</code></td>
<td><code>123.4</code></td>
<td>standard JSON</td>
</tr>
<tr>
<td>+0</td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td>standard JSON</td>
</tr>
<tr>
<td>-0</td>
<td><code>0</code></td>
<td><code>-0</code></td>
<td><code>-0</code></td>
<td>Standard JSON allows <code>-0</code> but serializes negative
    zero as <code>0</code> (losing the sign unnecessarily)</td>
</tr>
<tr>
<td>NaN</td>
<td><code>null</code></td>
<td><code>NaN</code></td>
<td><code>{"_nan":true}</code></td>
<td>Standard JSON: always encoded as <code>null</code></td>
<td></td>
</tr>
<tr>
<td>Infinity</td>
<td><code>null</code></td>
<td><code>Infinity</code></td>
<td><code>{"_inf":true}</code></td>
<td>Standard JSON: always encoded as <code>null</code></td>
</tr>
<tr>
<td>-Infinity</td>
<td><code>null</code></td>
<td><code>-Infinity</code></td>
<td><code>{"_ninf":true}</code></td>
<td>Standard JSON: always encoded as <code>null</code></td>
</tr>
<tr>
<td>"köhä"</td>
<td><code>"köhä"</code></td>
<td><code>"k\xf6h\xe4"</code></td>
<td><code>"k\u00f6h\u00e4"</code></td>
<td></td>
</tr>
<tr>
<td>U+00FC</td>
<td><code>"\u00fc"</code></td>
<td><code>"\xfc"</code></td>
<td><code>"\u00fc"</code></td>
<td></td>
</tr>
<tr>
<td>U+ABCD</td>
<td><code>"\uabcd"</code></td>
<td><code>"\uabcd"</code></td>
<td><code>"\uabcd"</code></td>
<td></td>
</tr>
<tr>
<td>U+1234ABCD</td>
<td><code>"U+1234abcd"</code></td>
<td><code>"\U1234abcd"</code></td>
<td><code>"U+1234abcd"</code></td>
<td>Non-BMP characters are not standard Ecmascript, JX format borrowed from Python</td>
</tr>
<tr>
<td>object</td>
<td><code>{"my_key":123}</code></td>
<td><code>{my_key:123}</code></td>
<td><code>{"my_key":123}</code></td>
<td>ASCII keys matching identifer requirements encoded without quotes in JX</td>
</tr>
<tr>
<td>array</td>
<td><code>["foo","bar"]</code></td>
<td><code>["foo","bar"]</code></td>
<td><code>["foo","bar"]</code></td>
<td></td>
</tr>
<tr>
<td>buffer</td>
<td><code>n/a</code></td>
<td><code>|deadbeef|</code></td>
<td><code>{"_buf":"deadbeef"}</code></td>
<td></td>
</tr>
<tr>
<td>pointer</td>
<td><code>n/a</code></td>
<td><code>(0xdeadbeef)<br/>(DEADBEEF)</code></td>
<td><code>{"_ptr":"0xdeadbeef"}<br/>{"_ptr":"DEADBEEF"}</code></td>
<td>Representation inside parentheses or quotes is platform specific</td>
</tr>
<tr>
<td>NULL pointer</td>
<td><code>n/a</code></td>
<td><code>(null)</code></td>
<td><code>{"_ptr":"null"}</code></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td><code>n/a</code></td>
<td><code>{_func:true}</code></td>
<td><code>{"_func":true}</code></td>
<td>Standard JSON: encoded as <code>null</code> inside arrays, otherwise omitted</td>
</tr>
<tr>
<td>lightfunc</td>
<td><code>n/a</code></td>
<td><code>{_func:true}</code></td>
<td><code>{"_func":true}</code></td>
<td>Formats like ordinary functions</td>
</tr>
</tbody>
</table><h2 class="sectiontitle" id="customjson.6">Limitations <a class="sectionlink" href="#customjson.6">§</a></h2><p>Some limitations include:</p><ul>
<li>Only enumerable own properties are serialized in any of the formats.</li>
<li>Array properties (other than the entries) are not serialized.  This would
    be useful in e.g. logging, e.g. as <code>[1,2,3,"type":"point"]</code>.</li>
<li>There is no automatic revival of special values when parsing JC data.</li>
<li>There is no canonical encoding.  This would be easy to arrange with a simple
    option to sort object keys during encoding.</li>
</ul><p>(See internal documentation for more future work issues.)</p><hr/><h1 class="sectiontitle" id="customdirectives">Custom directives <a class="sectionlink" href="#customdirectives">§</a></h1><p>Ecmascript E5/E5.1 employs a
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-14.1">directive prologue</a>
to allow version or implementation specific features be activated.
The standard only provides one such directive, <code>"use strict"</code>, while
asm.js uses <code>"use asm"</code>.  Duktape custom directives are discussed
in this section.</p><h2 class="sectiontitle" id="use-duk-notail">use duk notail <a class="sectionlink" href="#use-duk-notail">§</a></h2><p>The <code>use duk notail</code> directive indicates that the function should
never be tail called.  Tail calls affect the call stack so they are visible in
stack traces (usually harmless) and affect functions which inspect the call stack
using e.g. <code>Duktape.act()</code>.  This directive may be useful in special
cases to ensure call stack has a known shape.  Example:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">noTailCall</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="string">'use duk notail'</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// ...</span>
<span class="cbracket">}</span>
</pre><p>Native functions are never tailcalled, so a corresponding declaration is not
necessary for them.</p><hr/><h1 class="sectiontitle" id="errorobjects">Error objects <a class="sectionlink" href="#errorobjects">§</a></h1><h2 class="sectiontitle" id="errorobjects.1">Property summary <a class="sectionlink" href="#errorobjects.1">§</a></h2><p>Ecmascript Error objects have very few standard properties, so many
Ecmascript implementations have added quite a few custom properties.
Duktape uses standard Error properties but also borrows the most useful
properties used by other implementations.  The number of "own" properties
of error objects is minimized to keep error objects as small as possible.</p><p>Error objects have the following properties (mostly inherited):</p><table>
<thead>
<tr><th>Property name</th><th>Compatibility</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td class="propname">name</td><td>standard</td><td>Name of error, e.g. <code>TypeError</code>, inherited</td></tr>
<tr><td class="propname">message</td><td>standard</td><td>Optional message of error, own property, empty message inherited if absent</td></tr>
<tr><td class="propname">fileName</td><td>Rhino</td><td>Filename related to error source, inherited accessor</td></tr>
<tr><td class="propname">lineNumber</td><td>Rhino</td><td>Linenumber related to error source, inherited accessor</td></tr>
<tr><td class="propname">stack</td><td>V8</td><td>Traceback as a multi-line human redable string, inherited accessor</td></tr>
</tbody>
</table><p>If Duktape is compiled with traceback support:</p><ul>
<li><code>stack</code>, <code>fileName</code>, and <code>lineNumber</code> are accessor
    properties inherited from <code>Error.prototype</code>.</li>
<li>The raw traceback data needed by the accessor properties is stored in an internal
    property (<code>\xFFtracedata</code>) which is not normally accessible from
    Ecmascript code.</li>
</ul><p>If Duktape is compiled without traceback support:</p><ul>
<li>The <code>stack</code> accessor will be equivalent to
    <code>Error.prototype.toString()</code>, so that printing the stacktrace
    always produces a useful result.</li>
<li><code>fileName</code> and <code>lineNumber</code> will be own properties of the
    Error object.</li>
</ul><p>When error objects are created using the Duktape API from C code and the
caller does not give a format string for a <code>message</code>, the <code>message</code>
property is set to a numeric error code given in the API call.  The type of
<code>message</code> will be number in this case; normally error messages are
strings.   In minimized Duktape builds all errors generated internally by
Duktape use numeric error codes only.</p><p>An object is considered an "error object" if its internal prototype
chain contains the (original) <code>Error.prototype</code> object.  Only
objects matching this criteria get augmented with e.g. traceback data.</p><h2 class="sectiontitle" id="errorobjects.2">Traceback <a class="sectionlink" href="#errorobjects.2">§</a></h2><p>The <code>stack</code> property is an accessor (setter/getter) property
which provides a printable traceback related to an error.  The traceback
reflects the call stack when the error object was created (not thrown).
Traceback data is automatically collected and added to an object:</p><ul>
<li>when an Error instance is constructed;</li>
<li>when an error is thrown from C code using the Duktape API;</li>
<li>when an error is thrown from inside Duktape.</li>
</ul><p>The data used to create the traceback is stored in an internal property
(<code>\xFFtracedata</code>), in an internal and version-dependent format
described
<a href="https://github.com/svaarala/duktape/blob/master/doc/error-objects.rst">error-objects.rst</a>.
You shouldn't access the traceback data directly.</p><p>The printable traceback format is intended to be human readable only.
You shouldn't rely on an exact traceback format as it may change between
versions.  As an example of the current traceback format, the program:</p><pre class="ecmascript-code"><span class="comment">// shortened from tests/ecmascript/test-dev-traceback-example.js</span>
<span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">decodeURIComponent</span><span class="symbol">(</span><span class="string">'%e1%a9%01'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// invalid utf-8</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">.</span><span class="normal">stack</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>would print something like:</p><pre>
URIError: invalid input
        duk_bi_global.c:316
        decodeURIComponent  native strict preventsyield
        global tests/ecmascript/test-dev-traceback-example.js:3 preventsyield
</pre><p>In builds where tracebacks are disabled, the <code>stack</code> accessor
will return the same value as calling <code>toString()</code> on the error
would.  This means you can always print <code>e.stack</code> and get a useful
output.</p><p>The most portable traceback printing approach is something like:</p><pre class="ecmascript-code"><span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">decodeURIComponent</span><span class="symbol">(</span><span class="string">'%e1%a9%01'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// invalid utf-8</span>
<span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// Print stacktrace on at least Duktape and V8, or a standard error</span>
<span class="normal">    </span><span class="comment">// string otherwise.</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">.</span><span class="normal">stack </span><span class="symbol">||</span><span class="normal"> e</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>Attempt to write to <code>stack</code> is silently ignored.  You can still
override the accessor by defining an own property of the same name explicitly
with <code>Object.defineProperty()</code>.  This behavior differs from V8 where
<code>stack</code> is an own property of the Error instance, and if you assign a
value to <code>stack</code>, the value reads back as assigned.</p><h2 class="sectiontitle" id="error-handlers">Error handlers (errCreate and errThrow) <a class="sectionlink" href="#error-handlers">§</a></h2><p>If <code>Duktape.errCreate</code> has been set, it is called right after
Duktape has added traceback information to an object, and can process the
error further or even replace the error value entirely.  The error handler
only gets called with <code>Error</code> instances, and its return value is
used as the final error value.  If the error handler throws an error, that
error replaces the original error.  The error handler is usually called only once
per error.  However, in corner cases related to constructors, the error handler
can be called multiple times for a single error value.</p><p>An error handler should avoid overwriting any properties already
present in an object, as that would be quite confusing for other code.
In general, an error handler should always avoid throwing an error, as that
error replaces the original error and would also be confusing.  As a specific
example, an error handler must not try to add a new property to a non-extensible
object, as that would cause a <code>TypeError</code>.</p><p>Below is an example error handler for adding a creation timestamp to
errors at their creation:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">errCreate </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!(</span><span class="normal">e </span><span class="keyword">instanceof</span><span class="normal"> Error</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this check is not really needed because errCreate only gets</span>
<span class="normal">        </span><span class="comment">// called with Error instances</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="string">'created'</span><span class="normal"> </span><span class="keyword">in</span><span class="normal"> e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// already augmented or conflicting property present</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Object</span><span class="symbol">.</span><span class="function">isExtensible</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// object not extensible, don't try to add a new property</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    e</span><span class="symbol">.</span><span class="normal">created </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Date</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>To remove the handler, delete the property (setting it to e.g. <code>null</code>
does not work and causes a <code>TypeError</code> when Duktape attempts to
call the <code>null</code> value):</p><pre class="ecmascript-code"><span class="comment">// Remove error handler for error creation</span>
<span class="keyword">delete</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">errCreate</span><span class="symbol">;</span>
</pre><p>Similarly, if <code>Duktape.errThrow</code> has been set, it is called
right before an error is thrown, and can process or replace the error value.
Because Ecmascript allows any value type to be thrown, the error handler
may get called with arbitrary input values (not just <code>Error</code>
instances).  It may also be called more than once for the same value because
an error can be re-thrown multiple times.</p><p>For example, to add a throw timestamp (recording the first time the object
has been thrown) to errors:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">errThrow </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!(</span><span class="normal">e </span><span class="keyword">instanceof</span><span class="normal"> Error</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// refuse to touch anything but Error instances</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="string">'thrown'</span><span class="normal"> </span><span class="keyword">in</span><span class="normal"> e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// already augmented or conflicting property present</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Object</span><span class="symbol">.</span><span class="function">isExtensible</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// object not extensible, don't try to add a new property</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    e</span><span class="symbol">.</span><span class="normal">thrown </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Date</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> e</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>Again, to remove the handler, delete the property:</p><pre class="ecmascript-code"><span class="comment">// Remove error handler for error throwing</span>
<span class="keyword">delete</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">errThrow</span><span class="symbol">;</span>
</pre><h2 class="sectiontitle" id="errorobjects.4">Current limitations <a class="sectionlink" href="#errorobjects.4">§</a></h2><ul>
<li>There is no cause chain support.  Cause chains would be useful but there
    are no cause chains in Ecmascript, nor does there seem to be a de facto
    standard for them.</li>
<li>These is currently no way to access traceback elements programmatically.</li>
<li>If an error is created with a non-constructor function call to a custom
    error class (<code>MyError('msg')</code> instead of <code>new MyError('msg')</code>)
    it won't get augmented with custom fields such as traceback data.  When
    called as a constructor custom errors inheriting from <code>Error</code> get
    augmented normally.  Built-in standard errors (like <code>TypeError</code>)
    always get augmented, even when created with a non-constructor function call
    (the tracebacks look slightly different depending on how the error is
    created, though).</li>
</ul><hr/><h1 class="sectiontitle" id="functionobjects">Function objects <a class="sectionlink" href="#functionobjects">§</a></h1><h2 class="sectiontitle" id="ecmascript-function-properties">Properties of Ecmascript functions <a class="sectionlink" href="#ecmascript-function-properties">§</a></h2><p>Duktape Function objects add a few properties to standard Ecmascript
properties.  The table below summarizes properties assigned to newly
created function instances (properties can of course be added or removed
afterwards):</p><table>
<thead>
<tr><th>Property name</th><th>Compatibility</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td class="propname">length</td><td>standard</td><td>Function (nominal) argument count (if relevant).  Present for all Function objects, including bound functions.</td></tr>
<tr><td class="propname">prototype</td><td>standard</td><td>Prototype used for new objects when called as a constructor.  Present for most constructable Function objects, not copied to bound functions.</td></tr>
<tr><td class="propname">caller</td><td>standard</td><td>Accessor which throws an error.  Present for strict functions and bound functions.  Not copied to bound functions.  (If <code>DUK_OPT_NONSTD_FUNC_CALLER_PROPERTY</code> is given, non-strict functions will get a non-standard <code>caller</code> property.)</td></tr>
<tr><td class="propname">arguments</td><td>standard</td><td>Accessor which throws an error.  Present for strict functions and bound functions.  Not copied to bound functions.</td></tr>
<tr><td class="propname">name</td><td>Duktape</td><td>Function name, see below.  Copied to bound function from target function.</td></tr>
<tr><td class="propname">fileName</td><td>Duktape</td><td>Filename or context where function was declared (same name as in error tracebacks).  Copied to bound function from target function. </td></tr>
<tr><td class="propname">callee</td><td>n/a</td><td>Never assigned by default (listed here to clarify relationship to "caller" property).</td></tr>
</tbody>
</table><p>The <code>name</code> property is assigned to all functions and is also
the name used in tracebacks.  It is assigned as follows:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">funcDecl</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Function declaration: 'name' is declaration name, here 'funcDecl'. */</span>
<span class="cbracket">}</span>

<span class="keyword">var</span><span class="normal"> foo </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="function">namedFunc</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Named function expression: 'name' is the name used in expression,</span>
<span class="comment">     * here 'namedFunc' (not 'foo').</span>
<span class="comment">     */</span>
<span class="cbracket">}</span>

<span class="keyword">var</span><span class="normal"> bar </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Anonymous function expression: 'name' is the empty string. */</span>
<span class="cbracket">}</span>
</pre><div class="note">
Several Ecmascript built-in functions have properties different from user
created Functions.
</div><h2 class="sectiontitle" id="duktapec-function-properties">Properties of Duktape/C functions <a class="sectionlink" href="#duktapec-function-properties">§</a></h2><p>User-created Duktape/C functions (<code>duk_push_c_function()</code>) have
a different set of properties to reduce Function object memory footprint:</p><table>
<thead>
<tr><th>Property name</th><th>Compatibility</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td class="propname">length</td><td>standard</td><td>
Function argument count, matches argument to <code>duk_push_c_function()</code>, 0 for varargs.
Non-writable and non-configurable.</td></tr>
</tbody>
</table><p>Note in particular that the standard <code>prototype</code>, <code>caller</code>,
and <code>arguments</code> properties are missing by default.  This is not strictly
compliant but is important to reduce function footprint.  User code can of course
assign these but is not required to do so.</p><h2 class="sectiontitle" id="duktapec-lightfunc-properties">Properties of lightweight Duktape/C functions <a class="sectionlink" href="#duktapec-lightfunc-properties">§</a></h2><p>Lightweight functions have a set of non-configurable, non-writable virtual
properties listed below.  Like normal functions, they inherit further properties
from <code>Function.prototype</code>.</p><table>
<thead>
<tr><th>Property name</th><th>Compatibility</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td class="propname">length</td><td>standard</td><td>Function (nominal) argument count.</td></tr>
<tr><td class="propname">name</td><td>Duktape</td><td>Function name: <code>"light_&lt;PTR&gt;_&lt;FLAGS&gt;"</code>.</td></tr>
</tbody>
</table><p>The <code>name</code> property is an automatically generated virtual
function name. &lt;PTR&gt; is a platform dependent dump of the Duktape/C
function pointer, and &lt;FLAGS&gt; is a raw hex dump of the 16-bit internal
control fields (the format is Duktape internal).  You shouldn't rely on a
specific format.  For example:</p><pre>
duk&gt; print(myLightFunc.name);
light_0805b94c_0511
</pre><p>As for ordinary functions, a lightfunc coerces to an implementation
dependent string.  You shouldn't rely on a specific format.  For example:</p><pre>
duk&gt; print(myLightFunc);
function light_0805b94c_0511() {/* light */}
</pre><hr/><h1 class="sectiontitle" id="debugger">Debugger <a class="sectionlink" href="#debugger">§</a></h1><div class="note">
<b>The debugger feature is experimental at present, which means that it may
be unstable and change in an incompatible fashion even in a minor release.</b>
</div><p>Duktape has built-in debugger support as an option you can enable during
compilation.  Debugger support adds about 10kB of code footprint and has
very minimal memory footprint.</p><p>The debugger is based on the following main concepts:</p><ul>
<li>Duktape provides a built-in <b>debug protocol</b> which is the same for all
    applications.  The application doesn't need to parse or understand the
    debug protocol.  The debug protocol is a compact binary protocol so that
    it works well on low memory targets with low speed connectivity.  There
    is a <b>JSON mapping</b> for the debug protocol and a JSON debug proxy to
    make it easier to integrate a debug client.</li>
<li>The debug protocol runs over a reliable, stream-based <b>debug transport</b>.
    To maximize portability, the concrete transport is provided by application
    code as a set of callbacks implementing a stream interface.  A streamed
    transport allows unbuffered streaming of debug messages, which keeps memory
    usage very low.</li>
<li>A <b>debug client</b> terminates the transport connection and uses the Duktape
    debug protocol to interact with Duktape internals: pause/resume, stepping,
    breakpoints, eval, etc.  You can also use the JSON debug proxy for easier
    integration.</li>
<li>A very narrow <b>debug API</b> is used by the application code to attach and
    detach a debugger, and to provide the callbacks needed to implement the
    debug transport.  All other debug activity happens through the debug
    protocol which is implemented by Duktape directly with no application
    involvement.</li>
</ul><p>The most appropriate debug transport varies a lot between debug targets;
it can be Wi-Fi, Bluetooth, a serial line, a stream embedded into a custom
management protocol, etc.  Although there is no "standard" transport, a TCP
connection is a useful default.  The Duktape distributable includes all the
pieces you need to get started with debugging using a TCP transport:</p><ul>
<li>An example implementation of the callbacks needed for a TCP transport:
    <a href="https://github.com/svaarala/duktape/blob/master/examples/debug-trans-socket/">duk_debug_trans_socket.c</a></li>
<li>Debugger support for the Duktape command line tool (<code>duk</code>) using
    the TCP transport: <code>--debugger</code> option</li>
<li>A debugger web UI based on
    <a href="http://nodejs.org/">Node.js</a>,
    <a href="http://expressjs.com/">Express</a>, and
    <a href="http://socket.io/">socket.io</a>:
    <a href="https://github.com/svaarala/duktape/blob/master/debugger/">duk_debug.js</a></li>
</ul><p>The Node.js based debugger web UI (<code>duk_debug.js</code>) can connect
to the Duktape command line, but can also talk directly with any other target
implementing a TCP transport.  You can also customize it to use a different
transport or use a proxy which converts between TCP and your custom transport.
It's also possible to write your own debug client from scratch and e.g.
integrate it to a custom IDE.  You can integrate directly with a debug target
using the binary debug protocol, or use the JSON proxy provided by
<code>duk_debug.js</code>.</p><p>For more details on the implementation and how to get started, see:</p><ul>
<li><a href="https://github.com/svaarala/duktape/blob/master/debugger/README.rst">debugger/README.rst</a></li>
<li><a href="https://github.com/svaarala/duktape/blob/master/doc/debugger.rst">debugger.rst</a></li>
</ul><hr/><h1 class="sectiontitle" id="modules">Modules <a class="sectionlink" href="#modules">§</a></h1><h2 class="sectiontitle" id="modules.1">Overview <a class="sectionlink" href="#modules.1">§</a></h2><p>Duktape has a built-in minimal module loading framework based on
<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS modules version 1.1.1</a>.
The internals are documented in
<a href="https://github.com/svaarala/duktape/blob/master/doc/modules.rst">modules.rst</a>.
A recommended (but not mandatory) C module convention is described in
<a href="https://github.com/svaarala/duktape/blob/master/doc/c-module-convention.rst">c-module-convention.rst</a>.
</p><p>You can load modules from Ecmascript code with the global <code>require()</code> function:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> mod </span><span class="symbol">=</span><span class="normal"> </span><span class="function">require</span><span class="symbol">(</span><span class="string">'foo/bar'</span><span class="symbol">);</span>
<span class="normal">mod</span><span class="symbol">.</span><span class="function">hello</span><span class="symbol">();</span>
</pre><p>Modules are defined by Ecmascript code running in a special environment
defined by the CommonJS modules specification.  Inside this environment,
variable/function declarations are local to the module and don't affect the
global object.  The environment also provides three special symbols related
to module loading: <code>exports</code> for exporting module symbols,
<code>module</code> for providing module metadata (<code>module.id</code>
in particular), and <code>require()</code> for loading further modules with
relative module identifiers resolved in the context of the current module.
Example:</p><pre class="ecmascript-code"><span class="comment">// foo/bar.js</span>
<span class="keyword">var</span><span class="normal"> text </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'Hello world!'</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// not visible outside the module</span>
<span class="keyword">var</span><span class="normal"> quux </span><span class="symbol">=</span><span class="normal"> </span><span class="function">require</span><span class="symbol">(</span><span class="string">'./quux'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// loads foo/quux</span>
<span class="normal">exports</span><span class="symbol">.</span><span class="normal">hello </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">text</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="symbol">;</span>
</pre><p>Because Duktape is embeddable and portable to different environments there
is no standard way to search for modules.  <b>User code must provide a module
search function</b> in <code>Duktape.modSearch</code> for module loading to work.
The module search function essentially maps a module identifier to the source
code of the module (see below for more details).  Example:</p><pre class="ecmascript-code"><span class="comment">// See module search function details below.</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">modSearch </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'loading module:'</span><span class="symbol">,</span><span class="normal"> id</span><span class="symbol">);</span>
<span class="normal">    </span><span class="comment">// Return source code for module or throw an error.</span>
<span class="cbracket">}</span><span class="symbol">;</span>
</pre><h2 class="sectiontitle" id="modules.2">Module search function <a class="sectionlink" href="#modules.2">§</a></h2><p>The module search function encapsulates all platform specific concerns,
such as module search paths and file system access, related to finding a
module matching a certain identifier:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">modSearch </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">,</span><span class="normal"> require</span><span class="symbol">,</span><span class="normal"> exports</span><span class="symbol">,</span><span class="normal"> module</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// ...</span>
<span class="cbracket">}</span><span class="symbol">;</span>
</pre><p>The arguments of the module search function are:</p><ul>
<li>A fully resolved module ID.  Relative IDs are converted to absolute
    IDs and there are no unresolved <code>.</code> or <code>..</code>
    ID terms.</li>
<li>A <code>require()</code> function for loading further modules.
    Relative module IDs are resolved relative to the current module.
    For instance, if <code>foo/bar</code> is being loaded, the
    <code>require()</code> function given to the module search function
    would resolve <code>./quux</code> to <code>foo/quux</code>.</li>
<li>A <code>exports</code> object to export symbols during module search.
    Writing to exports within the module search function is only needed
    when loading native (Duktape/C) modules.</li>
<li>A <code>module</code> object which provides metadata about the module
    being loaded.  The only property provided now is <code>module.id</code>,
    a resolved absolute identifier for the module being loaded.</li>
</ul><p>If a module is not found, the module search function is expected to throw
an error.  This error will propagate out to the code which originally called
<code>require()</code> so it should have a useful error message containing the
module identifier.  Any changes made to <code>exports</code> before throwing
the error are thrown away.</p><p>If a module is found, the module search function can return a string
providing the source code for the module.  Duktape will then take care of
compiling and executing the module code so that module symbols get registered
into the <code>exports</code> object.</p><p>The module search function can also add symbols directly to the
<code>exports</code> object.  This can be used to implement native (Duktape/C)
modules and platform specific DLL loading support.  For example, the module
search function could call a native module initializer (provided by a DLL)
which registered all the native functions and constants into the
<code>exports</code> object.</p><p>To support the native module case, the module search function can also
return <code>undefined</code> (or any non-string value), in which case
Duktape will assume that the module was found but has no Ecmascript source
to execute.  Symbols written to <code>exports</code> in the module search
function are the only symbols provided by the module.</p><p>Hybrid modules containing both C and Ecmascript code are also supported:
simply write native symbols into the <code>exports</code> table inside the
module search function, and return the module's Ecmascript code.  Duktape
will then execute the Ecmascript code, which can access symbols already
registered into the <code>exports</code> table and register further symbols.</p><p>The module search function can be either an Ecmascript function or a
Duktape/C function.</p><h2 class="sectiontitle" id="modules.3">Implementing a module search function <a class="sectionlink" href="#modules.3">§</a></h2><p>Here's a simply module search stub which provides two modules:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">modSearch </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'foo'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">'exports.hello = function() { print("Hello from foo!"); };'</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'bar'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">'exports.hello = function() { print("Hello from bar!"); };'</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Error</span><span class="symbol">(</span><span class="string">'module not found: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id</span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="symbol">;</span>
</pre><p>A more practical module search function is almost always platform dependent
because modules are most often loaded from disk.  Usually a Duktape/C binding
is needed to access the file system.  The example below loads modules using a
hypothetical <code>readFile</code> function:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">modSearch </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* readFile() reads a file from disk, and returns a string or undefined.</span>
<span class="comment">     * 'id' is in resolved canonical form so it only contains terms and</span>
<span class="comment">     * slashes, and no '.' or '..' terms.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> res</span><span class="symbol">;</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'loading module:'</span><span class="symbol">,</span><span class="normal"> id</span><span class="symbol">);</span>

<span class="normal">    res </span><span class="symbol">=</span><span class="normal"> </span><span class="function">readFile</span><span class="symbol">(</span><span class="string">'/modules/'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'.js'</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> res </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> res</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Error</span><span class="symbol">(</span><span class="string">'module not found: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>The following module search function supports pure C, pure Ecmascript, and
mixed modules.  C modules are loaded and initialized with a hypothetical
<code>loadAndInitDll</code> function which loads a DLL, and if found, calls an
init function so that the DLL initializer can register exported symbols:</p><pre class="ecmascript-code"><span class="normal">Duktape</span><span class="symbol">.</span><span class="normal">modSearch </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">,</span><span class="normal"> require</span><span class="symbol">,</span><span class="normal"> exports</span><span class="symbol">,</span><span class="normal"> module</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* readFile(): as above.</span>
<span class="comment">     * loadAndInitDll(): load DLL, call its init function, return true/false.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> name</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> src</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> found </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'loading module:'</span><span class="symbol">,</span><span class="normal"> id</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* DLL check.  DLL init function is platform specific.  It gets 'exports'</span>
<span class="comment">     * but also 'require' so that it can require further modules if necessary.</span>
<span class="comment">     */</span>
<span class="normal">    name </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'/modules/'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'.so'</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">loadAndInitDll</span><span class="symbol">(</span><span class="normal">name</span><span class="symbol">,</span><span class="normal"> require</span><span class="symbol">,</span><span class="normal"> exports</span><span class="symbol">,</span><span class="normal"> module</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'loaded DLL:'</span><span class="symbol">,</span><span class="normal"> name</span><span class="symbol">);</span>
<span class="normal">        found </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* Ecmascript check. */</span>
<span class="normal">    name </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'/modules/'</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'.js'</span><span class="symbol">;</span>
<span class="normal">    src </span><span class="symbol">=</span><span class="normal"> </span><span class="function">readFile</span><span class="symbol">(</span><span class="normal">name</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> src </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'loaded Ecmascript:'</span><span class="symbol">,</span><span class="normal"> name</span><span class="symbol">);</span>
<span class="normal">        found </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* Must find either a DLL or an Ecmascript file (or both) */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">found</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Error</span><span class="symbol">(</span><span class="string">'module not found: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> id</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* For pure C modules, 'src' may be undefined which is OK. */</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> src</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>The module search function could also load modules from a compressed
in-memory store, or load the modules over the network.  However, a module
search function cannot do a coroutine yield, so network access will block the
application; it is most useful for testing.</p><!-- XXX: this is just a placeholder, perhaps a separate guide section or integrate
     better with text elsewhere in this section.
--><h2 class="sectiontitle" id="writing-c-modules">Writing modules in C <a class="sectionlink" href="#writing-c-modules">§</a></h2><p>There's a recommended (but not mandatory) convention for writing C modules, see
<a href="https://github.com/svaarala/duktape/blob/master/doc/c-module-convention.rst">c-module-convention.rst</a>.</p><p>Most C modules will need the following parts:</p><pre class="c-code"><span class="comment">/*</span>
<span class="comment"> *  Identify module</span>
<span class="comment"> */</span>

<span class="comment">/* Include duktape.h and whatever platform headers are needed. */</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"duktape.h"</span>

<span class="comment">/*</span>
<span class="comment"> *  Duktape/C functions providing module functionality.</span>
<span class="comment"> */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_func_1</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* ... */</span>
<span class="cbracket">}</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_func_2</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* ... */</span>
<span class="cbracket">}</span>

<span class="comment">/* ... */</span>

<span class="comment">/*</span>
<span class="comment"> *  Module initialization</span>
<span class="comment"> */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">duk_function_list_entry</span><span class="normal"> my_module_funcs</span><span class="symbol">[]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="string">"func1"</span><span class="symbol">,</span><span class="normal"> my_func_1</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="string">"func2"</span><span class="symbol">,</span><span class="normal"> my_func_2</span><span class="symbol">,</span><span class="normal"> DUK_VARARGS </span><span class="comment">/*nargs*/</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">duk_number_list_entry</span><span class="normal"> my_module_consts</span><span class="symbol">[]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="string">"FLAG_FOO"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">double</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0.0</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">/* Init function name is dukopen_&lt;modname&gt;. */</span>
<span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">dukopen_my_module</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">duk_push_object</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_put_function_list</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> my_module_funcs</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_put_number_list</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> my_module_consts</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* Return value is the module object.  It's up to the caller to decide</span>
<span class="comment">     * how to use the value, e.g. write to global object.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>The calling application which wants to load this module manually (outside
of CommonJS module loading) will then simply:</p><pre class="c-code"><span class="type">int</span><span class="normal"> </span><span class="function">main</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> argc</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">argv</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">;</span>

<span class="normal">    ctx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_create_heap_default</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* ... */</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* Module loading happens with a Duktape/C call wrapper. */</span>
<span class="normal">    </span><span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> dukopen_my_module</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_call</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_put_global_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"my_module"</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* my_module is now registered in the global object. */</span>
<span class="normal">    </span><span class="function">duk_eval_string_noresult</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"my_module.func2()"</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* ... */</span>

<span class="normal">    </span><span class="function">duk_destroy_heap</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>C modules can also be loaded using a CommonJS module loader, in which case
the module loader would call the init function (e.g. located from a DLL).</p><h2 class="sectiontitle" id="modules.5">Limitations <a class="sectionlink" href="#modules.5">§</a></h2><ul>
<li>Duktape does not support <code>module.exports</code>.  This also means that
    the return value from <code>require()</code> is always an object, and cannot
    be e.g. a constructor function.</li>
<li>When implementing native modules in the module search function, circular
    module references are not supported because the module's <code>exports</code>
    table is not registered by Duktape as a "module being loaded" before the
    module search function exits.  Circular module references are supported for
    pure Ecmascript modules.</li>
</ul><hr/><h1 class="sectiontitle" id="logging">Logging <a class="sectionlink" href="#logging">§</a></h1><p>Duktape has a built-in logging framework with a small footprint, reasonable
performance, and redirectable output.</p><p>Basic usage example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> val1 </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'foo'</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> val2 </span><span class="symbol">=</span><span class="normal"> </span><span class="number">123</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> val3 </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Date</span><span class="symbol">(</span><span class="number">123456789e3</span><span class="symbol">);</span>

<span class="keyword">var</span><span class="normal"> logger </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Logger</span><span class="symbol">();</span><span class="normal">  </span><span class="comment">// or new Duktape.Logger('logger name')</span>
<span class="normal">logger</span><span class="symbol">.</span><span class="function">info</span><span class="symbol">(</span><span class="string">'three values:'</span><span class="symbol">,</span><span class="normal"> val1</span><span class="symbol">,</span><span class="normal"> val2</span><span class="symbol">,</span><span class="normal"> val3</span><span class="symbol">);</span>
</pre><p>The example would print something like the following to <code>stdout</code>:</p><pre>
2014-10-17T19:26:42.141Z INF test.js: three values: foo 123 1973-11-29 23:33:09.000+02:00
</pre><p>See
<a href="https://github.com/svaarala/duktape/blob/master/doc/logging.rst">logging.rst</a>
for more info.</p><hr/><h1 class="sectiontitle" id="finalization">Finalization <a class="sectionlink" href="#finalization">§</a></h1><h2 class="sectiontitle" id="finalization.1">Overview of finalization <a class="sectionlink" href="#finalization.1">§</a></h2><p>An object which has an internal finalizer property in its prototype
chain (or in the object itself) is subject to finalization before being
freed.  The internal finalizer property is set using the <code>Duktape.fin()</code>
method with the object and the finalizer function as call arguments.
The current finalizer is read back by calling <code>Duktape.fin()</code>
with only the object as a call argument.  A finalizer can also be set/get from
C code using the <code>duk_get_finalizer()</code> and <code>duk_set_finalizer()</code>
API calls.  A finalizer can be either an Ecmascript function or a Duktape/C function.</p><p>A finalizer is triggered when an unreachable object is detected by
reference counting or mark-and-sweep.  Finalizers are also executed for all
remaining objects (regardless of their reachability status) when a heap is destroyed.
This guarantees that a finalizer gets executed at some point before a heap
is destroyed, which allows native resources (such as sockets and files) to
be freed reliably.</p><p>The finalizer function is called with the target object as its sole
argument.  The finalizer may rescue the object by creating a live reference
to the object before returning.  The return value is ignored, and any errors
thrown by the finalizer are silently ignored.  A finalizer may be called
multiple times (this may happen in special cases even when the object is not
rescued by the finalizer).  A finalizer should be careful to avoid e.g.
freeing a native resource twice in such cases.</p><p>Finalizers cannot currently yield.  The context executing the finalization
can currently be any coroutine in the heap.  (This will be fixed in the future.)
</p><h2 class="sectiontitle" id="finalization.2">Simple example <a class="sectionlink" href="#finalization.2">§</a></h2><p>Finalization example:</p><pre class="ecmascript-code"><span class="comment">// finalize.js</span>
<span class="keyword">var</span><span class="normal"> a</span><span class="symbol">;</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">init</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    a </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="number">123</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">print</span><span class="symbol">(</span><span class="string">'finalizer, foo -&gt;'</span><span class="symbol">,</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">print</span><span class="symbol">(</span><span class="string">'WARNING: finalizer failed (ignoring): '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> e</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">// create object, reference it through 'a'</span>
<span class="function">init</span><span class="symbol">();</span>

<span class="comment">// delete reference, refcount triggers finalization immediately</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'refcount finalizer'</span><span class="symbol">);</span>
<span class="normal">a </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span>

<span class="comment">// mark-and-sweep finalizing happens here (at the latest) if</span>
<span class="comment">// refcounting is disabled</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'mark-and-sweep finalizer'</span><span class="symbol">)</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">gc</span><span class="symbol">();</span>
</pre><p>The <code>try-catch</code> wrapper inside the finalizer of the above
example is strongly recommended.  An uncaught finalizer error is silently
ignored which can be confusing, as it may seem like the finalizer is not
getting executed at all.</p><p>If you run this with the Duktape command line tool (with the default
Duktape profile), you'll get:</p><pre>
$ duk finalize.js
refcount finalizer
finalizer, foo -&gt; 123
mark-and-sweep finalizer
Cleaning up...
</pre><h2 class="sectiontitle" id="finalization.3">Adding a finalizer to a prototype object <a class="sectionlink" href="#finalization.3">§</a></h2><p>If you have many objects of the same type, you can add a finalizer to the
prototype to minimize the property count of object instances:</p><pre class="ecmascript-code"><span class="comment">// Example of a hypothetical Socket object which is associated with a</span>
<span class="comment">// platform specific file descriptor.</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">Socket</span><span class="symbol">(</span><span class="normal">host</span><span class="symbol">,</span><span class="normal"> port</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">host </span><span class="symbol">=</span><span class="normal"> host</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">port </span><span class="symbol">=</span><span class="normal"> port</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> Platform</span><span class="symbol">.</span><span class="function">openSocket</span><span class="symbol">(</span><span class="normal">host</span><span class="symbol">,</span><span class="normal"> port</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">Socket</span><span class="symbol">.</span><span class="keyword">prototype</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x </span><span class="symbol">===</span><span class="normal"> Socket</span><span class="symbol">.</span><span class="keyword">prototype</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// called for the prototype itself</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">fd </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'number'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// already freed</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">try</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        Platform</span><span class="symbol">.</span><span class="function">closeSocket</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">fd</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">catch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'WARNING: finalizer failed for fd '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">fd </span><span class="symbol">+</span><span class="normal"> </span><span class="string">' (ignoring): '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> e</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">delete</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="symbol">);</span>

<span class="comment">// Any Socket instances are now finalized without registering explicit</span>
<span class="comment">// finalizers for them:</span>

<span class="keyword">var</span><span class="normal"> sock </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Socket</span><span class="symbol">(</span><span class="string">'localhost'</span><span class="symbol">,</span><span class="normal"> </span><span class="number">8080</span><span class="symbol">);</span>
</pre><hr/><h1 class="sectiontitle" id="coroutines">Coroutines <a class="sectionlink" href="#coroutines">§</a></h1><h2 class="sectiontitle" id="coroutines.1">Overview of coroutines <a class="sectionlink" href="#coroutines.1">§</a></h2><p>Duktape has a support for simple coroutines.  Execution is strictly nesting:
coroutine A resumes or initiates coroutine B, coroutine B runs until it yields
or finishes (either successfully or through an uncaught error), after which
coroutine A continues execution with the yield result.</p><p>Coroutines are created with <code>new Duktape.Thread()</code>, which gets as its
sole argument the initial function where the new coroutine begins execution on
its first resume.  The resume argument becomes the initial function's first (and
only) argument value.</p><p>A coroutine is resumed using <code>Duktape.Thread.resume()</code> which takes the
following arguments: the coroutine to resume, the resume value, and (optionally)
a flag indicating whether the resume value is an ordinary value or an error to
be injected into the target coroutine.  Injecting an error means that the resume
value will be "thrown" at the site of the target coroutine's last yield operation.
In other words, instead of returning with an ordinary value, the yield will
seemingly throw an error.</p><p>A coroutine yields its current execution using <code>Duktape.Thread.yield()</code>
which takes as its arguments: the value to yield, and (optionally) a flag indicating
whether the yield value is an ordinary value or an error to be thrown in the
context of the resuming coroutine.  In other words, an error value causes the
resume operation to seemingly throw an error instead of returning an ordinary
value.</p><p>If a coroutine exists successfully, i.e. the initial function finishes by
returning a value, it is handled similarly to a yield with the return value.
If a coroutine exists because of an uncaught error, it is handled similarly
to a yield with the error: the resume operation will rethrow that error in
the resuming coroutine's context.  In either case the coroutine which has
finished can no longer be resumed; attempt to do so will cause a TypeError.</p><p>There are currently strict limitations on when a yield is possible.
In short, a coroutine can only yield if its entire active call stack consists
of plain Ecmascript-to-Ecmascript calls.  The following prevent a yield if
they are present anywhere in the yielding coroutine's call stack:</p><ul>
<li>a Duktape/C function call</li>
<li>a constructor call</li>
<li>a getter/setter call</li>
<li>a proxy trap call</li>
<li>an <code>eval()</code> call</li>
<li><code>Function.prototype.call()</code> or <code>Function.prototype.apply()</code></li>
<li>a finalizer call</li>
</ul><h2 class="sectiontitle" id="coroutines.2">Example <a class="sectionlink" href="#coroutines.2">§</a></h2><p>A simple example of the basic mechanics of spawning, resuming, and yielding:</p><pre class="ecmascript-code"><span class="comment">// coroutine.js</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">yielder</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> yield </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">Thread</span><span class="symbol">.</span><span class="normal">yield</span><span class="symbol">;</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'yielder starting'</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'yielder arg:'</span><span class="symbol">,</span><span class="normal"> x</span><span class="symbol">);</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'resumed with'</span><span class="symbol">,</span><span class="normal"> </span><span class="function">yield</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'resumed with'</span><span class="symbol">,</span><span class="normal"> </span><span class="function">yield</span><span class="symbol">(</span><span class="number">2</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'resumed with'</span><span class="symbol">,</span><span class="normal"> </span><span class="function">yield</span><span class="symbol">(</span><span class="number">3</span><span class="symbol">));</span>

<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="string">'yielder ending'</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">123</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="keyword">var</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Thread</span><span class="symbol">(</span><span class="normal">yielder</span><span class="symbol">);</span>

<span class="function">print</span><span class="symbol">(</span><span class="string">'resume test'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'yielded with'</span><span class="symbol">,</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">Thread</span><span class="symbol">.</span><span class="function">resume</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'foo'</span><span class="symbol">));</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'yielded with'</span><span class="symbol">,</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">Thread</span><span class="symbol">.</span><span class="function">resume</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'bar'</span><span class="symbol">));</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'yielded with'</span><span class="symbol">,</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">Thread</span><span class="symbol">.</span><span class="function">resume</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'quux'</span><span class="symbol">));</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'yielded with'</span><span class="symbol">,</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">Thread</span><span class="symbol">.</span><span class="function">resume</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'baz'</span><span class="symbol">));</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'finished'</span><span class="symbol">);</span>
</pre><p>When executed with the <code>duk</code> command line tool, this prints:</p><pre>
$ duk coroutine.js
resume test
yielder starting
yielder arg: foo
yielded with 1
resumed with bar
yielded with 2
resumed with quux
yielded with 3
resumed with baz
yielder ending
yielded with 123
finished
</pre><a name="propertyvirtualization"></a><!-- for old links --><hr/><h1 class="sectiontitle" id="virtualproperties">Virtual properties <a class="sectionlink" href="#virtualproperties">§</a></h1><p>This section describes the two different mechanisms Duktape provides
for interacting with property accesses programmatically: accessor
properties and the <code>Proxy</code> object.</p><h2 class="sectiontitle" id="virtualization-accessors">Ecmascript E5 accessor properties (getters and setters) <a class="sectionlink" href="#virtualization-accessors">§</a></h2><h3 class="sectiontitle" id="virtualization-accessors.1">Overview of accessors <a class="sectionlink" href="#virtualization-accessors.1">§</a></h3><p>Ecmascript Edition 5 provides <b>accessor properties</b> (also called
"setters and getters") which allow property read/write operations to be
captured by a user function.  Setter/getter functions can be both Ecmascript
and Duktape/C functions.</p><p>Accessors are set up using <code>Object.defineProperty()</code> or
<code>Object.defineProperties()</code> from Ecmascript code, or using
<code><a href="api.html#duk_def_prop">duk_def_prop()</a></code> from C code.</p><h3 class="sectiontitle" id="virtualization-accessors.2">Example <a class="sectionlink" href="#virtualization-accessors.2">§</a></h3><p>To capture writes to <code>obj.color</code> so that you can validate the
color value and trigger a redraw as a side effect:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{}</span><span class="symbol">;</span>

<span class="normal">Object</span><span class="symbol">.</span><span class="function">defineProperty</span><span class="symbol">(</span><span class="normal">obj</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'color'</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    enumerable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">,</span>
<span class="normal">    configurable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">,</span>
<span class="normal">    get</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// current color is stored in the raw _color property here</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">_color</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    set</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">validateColor</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// only allow valid color formats to be assigned</span>
<span class="normal">            </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'invalid color: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> v</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">_color </span><span class="symbol">=</span><span class="normal"> v</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">redraw</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">);</span>

<span class="comment">// Change to red and trigger a redraw.</span>
<span class="normal">obj</span><span class="symbol">.</span><span class="normal">color </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'#ff0000'</span><span class="symbol">;</span>
</pre><h3 class="sectiontitle" id="virtualization-accessors.3">Limitations <a class="sectionlink" href="#virtualization-accessors.3">§</a></h3><p>Setters and getters have the advantage of being part of the E5 standard
and of being widely implemented.  However, they have significant limitations:</p><ul>
<li>They are limited to interacting with property read and write operations.
    You cannot capture property deletions, interact with object enumeration, etc.</li>
<li>They only apply to individual properties which you set up as accessors
    beforehand.  You cannot capture all property accesses of a certain object,
    which limits their usefulness in some scenarios, such as virtualizing arrays.</li>
<li>A standard property setter/getter function doesn't get the property key as an
    argument (this behavior is defined by the Ecmascript specification) which
    prevents sharing of setter/getter functions for multiple properties.  Duktape
    provides setter/getter functions with the property name as an additional,
    non-standard argument; see more discussion below.</li>
</ul><h3 class="sectiontitle" id="virtualization-accessors.4">Non-standard getter/setter key argument <a class="sectionlink" href="#virtualization-accessors.4">§</a></h3><p>Duktape provides the property key as a non-standard setter/getter function
argument when the setter/getter is triggered by a property access.  For instance,
when running <code>print(foo.bar)</code> the getter for the "bar" property would
get called, and that function would get "bar" as a (non-standard) argument:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{}</span><span class="symbol">;</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">myGetter</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// 'this' binding is the target object, 'key' is a non-standard argument</span>
<span class="cbracket">}</span>
<span class="keyword">function</span><span class="normal"> </span><span class="function">mySetter</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// 'this' binding is the target object, 'key' is a non-standard argument</span>
<span class="cbracket">}</span>
<span class="normal">Object</span><span class="symbol">.</span><span class="function">defineProperties</span><span class="symbol">(</span><span class="normal">obj</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// Same getter/setter can be used here</span>
<span class="normal">    key1</span><span class="symbol">:</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> enumerable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> configurable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> get</span><span class="symbol">:</span><span class="normal"> myGetter</span><span class="symbol">,</span><span class="normal"> set</span><span class="symbol">:</span><span class="normal"> mySetter </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    key2</span><span class="symbol">:</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> enumerable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> configurable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> get</span><span class="symbol">:</span><span class="normal"> myGetter</span><span class="symbol">,</span><span class="normal"> set</span><span class="symbol">:</span><span class="normal"> mySetter </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    key3</span><span class="symbol">:</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> enumerable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> configurable</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> get</span><span class="symbol">:</span><span class="normal"> myGetter</span><span class="symbol">,</span><span class="normal"> set</span><span class="symbol">:</span><span class="normal"> mySetter </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">// ...</span>
<span class="cbracket">}</span><span class="symbol">);</span>
</pre><p>However, setters and getters can be also called without doing a property
access; in these cases the argument will of course be missing:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> desc </span><span class="symbol">=</span><span class="normal"> Object</span><span class="symbol">.</span><span class="function">getOwnPropertyDescriptor</span><span class="symbol">(</span><span class="normal">obj</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'key1'</span><span class="symbol">);</span>
<span class="keyword">var</span><span class="normal"> getter </span><span class="symbol">=</span><span class="normal"> desc</span><span class="symbol">.</span><span class="normal">get</span><span class="symbol">;</span>
<span class="function">print</span><span class="symbol">(</span><span class="function">getter</span><span class="symbol">());</span><span class="normal">  </span><span class="comment">// invoke getter directly; key name will be 'undefined'</span>
</pre><p>With this technique you can share setter/getter functions, but you still need
to define each accessor property beforehand.  In particular, you can't virtualize
array elements in a reasonable manner, except for very small, fixed size arrays.</p><p>Also see
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-dev-nonstd-setget-key-argument.js">test-dev-nonstd-setget-key-argument.js</a>.</p><h3 class="sectiontitle" id="virtualization-accessors.5">Sharing a Duktape/C setter/getter without the non-standard key argument <a class="sectionlink" href="#virtualization-accessors.5">§</a></h3><div class="note">
This section should only be useful if you have disabled the non-standard
setter/getter key argument feature, which provides a much easier way of
sharing a setter/getter pair than the approach described in this section.
</div><p>You can also share a single pair of Duktape/C functions to virtualize
multiple property keys as follows.</p><p>First, a separate Ecmascript function is created for each setter/getter,
with each such function using the same underlying Duktape/C functions.  Second,
the Duktape/C function uses properties stored on the Ecmascript function
instance "through" which it was called to specialize its behavior.  Below, a
<code>key</code> property is stored in the Ecmascript function instance.</p><p>For each property, the setter/getter functions would be created as follows:</p><pre class="c-code"><span class="comment">/* Create Ecmascript function objects for 'key1' setter/getter. */</span>
<span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">my_setter</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">);</span>
<span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key1"</span><span class="symbol">);</span>
<span class="function">duk_put_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key"</span><span class="symbol">);</span>
<span class="function">duk_push_c_function</span><span class="symbol">(</span><span class="normal">my_getter</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="comment">/*nargs*/</span><span class="symbol">);</span>
<span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key1"</span><span class="symbol">);</span>
<span class="function">duk_put_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">2</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key"</span><span class="symbol">);</span>
<span class="comment">/* ... add accessor property to target object */</span>

<span class="comment">/* Create Ecmascript function objects for 'key2' setter/getter in</span>
<span class="comment"> * the same way, and so on for remaining properties.</span>
<span class="comment"> */</span>
</pre><p>The Duktape/C getter function would then (similarly for the setter):</p><pre class="c-code"><span class="keyword">static</span><span class="normal"> </span><span class="usertype">duk_ret_t</span><span class="normal"> </span><span class="function">my_getter</span><span class="symbol">(</span><span class="usertype">duk_context</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ctx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">key</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/* There are no positional arguments for the getter. */</span>

<span class="normal">    </span><span class="comment">/* Get the target object (e.g. if "foo.bar" is accessed, gets "foo")</span>
<span class="comment">     * from the 'this' binding.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="function">duk_push_this</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* Get the 'key' being accessed from the Ecmascript function which</span>
<span class="comment">     * "wraps" the my_getter native function.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="function">duk_push_current_function</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">duk_get_prop_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key"</span><span class="symbol">);</span>
<span class="normal">    key </span><span class="symbol">=</span><span class="normal"> </span><span class="function">duk_require_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* -&gt; [ this func key ] */</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">strcmp</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key1"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* Behavior for 'key1' */</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">strcmp</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"key2"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* Behavior for 'key2' */</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">/* ... */</span>
<span class="cbracket">}</span>
</pre><p>Separate Ecmascript function objects and pre-defined accessor properties on
the target object are still needed for each virtualized property.</p><h2 class="sectiontitle" id="virtualization-proxy-object">Ecmascript E6 (draft) Proxy subset <a class="sectionlink" href="#virtualization-proxy-object">§</a></h2><h3 class="sectiontitle" id="virtualization-proxy-object.1">Overview of Proxy <a class="sectionlink" href="#virtualization-proxy-object.1">§</a></h3><p>In addition to accessors, Duktape provides a subset implementation of the
Ecmascript E6 (draft) <code>Proxy</code> concept, see:</p><ul>
<li><a href="#es6-proxy">Proxy object (subset)</a>:
    discussion of current limitations in Duktape's <code>Proxy</code> implementation.</li>
<li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-objects">Proxy Objects (E6 draft)</a>:
    ES6 draft specification for the <code>Proxy</code> object.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy (Mozilla)</a>:
    Mozilla's description of the <code>Proxy</code> implemented in Firefox, contains a lot of examples.</li>
</ul><p>The Proxy object is much more powerful than setters/getters, but is not yet
a widely used feature of Ecmascript engines.</p><h3 class="sectiontitle" id="virtualization-proxy-object.2">Examples of has, get, set, and deleteProperty traps <a class="sectionlink" href="#virtualization-proxy-object.2">§</a></h3><p>To print a line whenever any property is accessed:</p><pre class="ecmascript-code"><span class="comment">// Underlying plain object.</span>
<span class="keyword">var</span><span class="normal"> target </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="string">'bar'</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">// Handler table, provides traps for interaction (can be modified on-the-fly).</span>
<span class="keyword">var</span><span class="normal"> handler </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    has</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'has called for key='</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> key </span><span class="keyword">in</span><span class="normal"> targ</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// return unmodified existence status</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    get</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> recv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'get called for key='</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">];</span><span class="normal">  </span><span class="comment">// return unmodified value</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    set</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> val</span><span class="symbol">,</span><span class="normal"> recv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'set called for key='</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> key </span><span class="symbol">+</span><span class="normal"> </span><span class="string">', val='</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> val</span><span class="symbol">);</span>
<span class="normal">        targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// must perform write to target manually if 'set' defined</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal">      </span><span class="comment">// true: indicate that property write was allowed</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    deleteProperty</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="string">'deleteProperty called for key='</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">];</span><span class="normal">  </span><span class="comment">// must perform delete to target manually if 'deleteProperty' defined</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">// true: indicate that property delete was allowed</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">// Create proxy object.</span>
<span class="keyword">var</span><span class="normal"> proxy </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Proxy</span><span class="symbol">(</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> handler</span><span class="symbol">);</span>

<span class="comment">// Proxy object is then accessed normally.</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'foo'</span><span class="normal"> </span><span class="keyword">in</span><span class="normal"> proxy</span><span class="symbol">);</span>
<span class="normal">proxy</span><span class="symbol">.</span><span class="normal">foo </span><span class="symbol">=</span><span class="normal"> </span><span class="number">321</span><span class="symbol">;</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">proxy</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">);</span>
<span class="keyword">delete</span><span class="normal"> proxy</span><span class="symbol">.</span><span class="normal">foo</span><span class="symbol">;</span>
</pre><p>A Proxy object can also be used to create a read-only version of an
underlying object (which is quite tedious otherwise):</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> proxy </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Proxy</span><span class="symbol">(</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// has and get are omitted: existence checks and reads go through to the</span>
<span class="normal">    </span><span class="comment">// target object automatically</span>

<span class="normal">    </span><span class="comment">// set returns false: rejects write</span>
<span class="normal">    set</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    </span><span class="comment">// deleteProperty returns false: rejects delete</span>
<span class="normal">    deleteProperty</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">);</span>
</pre><p>You can also create a write-only version of an object (which is not
possible otherwise):</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> proxy </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Proxy</span><span class="symbol">(</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    has</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'has not allowed'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">,</span>
<span class="normal">    get</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'read not allowed'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// set and deleteProperty are omitted: set/delete operations</span>
<span class="normal">    </span><span class="comment">// are allowed and go through to the target automatically</span>
<span class="cbracket">}</span><span class="symbol">);</span>
</pre><p>The following is a more convoluted example combining multiple (somewhat
artificial) behaviors:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> target </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> foo</span><span class="symbol">:</span><span class="normal"> </span><span class="string">'bar'</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">/*</span>
<span class="comment"> *  - 'color' behaves like in the getter/setter example, cannot be deleted</span>
<span class="comment"> *    (attempt to do so causes a TypeError)</span>
<span class="comment"> *</span>
<span class="comment"> *  - all string values are uppercased when read</span>
<span class="comment"> *</span>
<span class="comment"> *  - property names beginning with an underscore are read/write/delete</span>
<span class="comment"> *    protected in a few different ways, and their existence is denied</span>
<span class="comment"> */</span>

<span class="keyword">var</span><span class="normal"> handler </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    has</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this binding: handler table</span>
<span class="normal">        </span><span class="comment">// targ: underlying plain object (= target, above)</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> key</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// pretend that property doesn't exist</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">return</span><span class="normal"> key </span><span class="keyword">in</span><span class="normal"> targ</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    get</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> recv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this binding: handler table</span>
<span class="normal">        </span><span class="comment">// targ: underlying plain object (= target, above)</span>
<span class="normal">        </span><span class="comment">// key: key (can be any value, not just a string)</span>
<span class="normal">        </span><span class="comment">// recv: object being read from (= the proxy object)</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> key</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'attempt to access a read-protected property'</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// Return value: value provided as property lookup result.</span>
<span class="normal">        </span><span class="keyword">var</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> val </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> val</span><span class="symbol">.</span><span class="function">toUpperCase</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> val</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    set</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> val</span><span class="symbol">,</span><span class="normal"> recv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this binding: handler table</span>
<span class="normal">        </span><span class="comment">// targ: underlying plain object (= target, above)</span>
<span class="normal">        </span><span class="comment">// key: key (can be any value, not just a string)</span>
<span class="normal">        </span><span class="comment">// val: value</span>
<span class="normal">        </span><span class="comment">// recv: object being read from (= the proxy object)</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'color'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">validateColor</span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'invalid color: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> val</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                targ</span><span class="symbol">.</span><span class="normal">color </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">redraw</span><span class="symbol">();</span>

<span class="normal">                </span><span class="comment">// True: indicates to caller that property write allowed.</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// False: indicates to caller that property write rejected.</span>
<span class="normal">                </span><span class="comment">// In non-strict mode this is ignored silently, but in strict</span>
<span class="normal">                </span><span class="comment">// mode a TypeError is thrown.</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// Write to target.  We could also return true without writing to the</span>
<span class="normal">        </span><span class="comment">// target to simulate a successful write without changing the target.</span>
<span class="normal">        targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    deleteProperty</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this binding: handler table</span>
<span class="normal">        </span><span class="comment">// targ: underlying plain object (= target, above)</span>
<span class="normal">        </span><span class="comment">// key: key (can be any value, not just a string)</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'string'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">key </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'color'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// For 'color' a delete attempt causes an explicit error.</span>
<span class="normal">                </span><span class="keyword">throw</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">TypeError</span><span class="symbol">(</span><span class="string">'attempt to delete the color property'</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">===</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// False: indicates to caller that property delete rejected.</span>
<span class="normal">                </span><span class="comment">// In non-strict mode this is ignored silently, but in strict</span>
<span class="normal">                </span><span class="comment">// mode a TypeError is thrown.</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// Delete from target.  We could also return true without deleting</span>
<span class="normal">        </span><span class="comment">// from the target to simulate a successful delete without changing</span>
<span class="normal">        </span><span class="comment">// the target.</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> targ</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>
</pre><p>The ES6 draft semantics reject some property accesses even if the trap would
allow it.  This happens if the proxy's target object has a non-configurable
conflicting property; see E6 draft Sections 9.5.7, 9.5.8, 9.5.9, and 9.5.10 for details.
You can easily avoid any such behaviors by keeping the target object empty and,
if necessary, backing the virtual properties in an unrelated plain object.</p><h3 class="sectiontitle" id="virtualization-proxy-object.3">Examples of enumerate and ownKeys traps <a class="sectionlink" href="#virtualization-proxy-object.3">§</a></h3><p>The <code>enumerate</code> trap is invoked for enumeration
(<code>for (k in obj) { ... }</code>) while the <code>ownKeys</code> trap is
invoked by <code>Object.keys()</code> and <code>Object.getOwnPropertyNames()</code>.</p><p>To hide property names beginning with an underscore from enumeration and
<code>Object.keys()</code> and <code>Object.getOwnPropertyNames()</code>:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> target </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    foo</span><span class="symbol">:</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span>
<span class="normal">    bar</span><span class="symbol">:</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span>
<span class="normal">    _quux</span><span class="symbol">:</span><span class="normal"> </span><span class="number">3</span><span class="symbol">,</span>
<span class="normal">    _baz</span><span class="symbol">:</span><span class="normal"> </span><span class="number">4</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">var</span><span class="normal"> proxy </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Proxy</span><span class="symbol">(</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    enumerate</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// this binding: handler table</span>
<span class="normal">        </span><span class="comment">// targ: underlying plain object (= target, above)</span>

<span class="normal">        </span><span class="keyword">return</span><span class="normal"> Object</span><span class="symbol">.</span><span class="function">getOwnPropertyNames</span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">)</span>
<span class="normal">                     </span><span class="symbol">.</span><span class="function">filter</span><span class="symbol">(</span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> v</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">,</span>

<span class="normal">    ownKeys</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> Object</span><span class="symbol">.</span><span class="function">getOwnPropertyNames</span><span class="symbol">(</span><span class="normal">targ</span><span class="symbol">)</span>
<span class="normal">                     </span><span class="symbol">.</span><span class="function">filter</span><span class="symbol">(</span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> v</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!==</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">);</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">test</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> k </span><span class="keyword">in</span><span class="normal"> proxy</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="normal">k</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'foo' and 'bar'</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
<span class="function">test</span><span class="symbol">();</span>

<span class="function">print</span><span class="symbol">(</span><span class="normal">Object</span><span class="symbol">.</span><span class="function">keys</span><span class="symbol">(</span><span class="normal">proxy</span><span class="symbol">));</span><span class="normal">                 </span><span class="comment">// prints 'foo,bar'</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">Object</span><span class="symbol">.</span><span class="function">getOwnPropertyNames</span><span class="symbol">(</span><span class="normal">proxy</span><span class="symbol">));</span><span class="normal">  </span><span class="comment">// prints 'foo,bar'</span>
</pre><h3 class="sectiontitle" id="virtualization-proxy-object.4">Using Proxy with a constructor function <a class="sectionlink" href="#virtualization-proxy-object.4">§</a></h3><p>If a constructor returns an object value, that value replaces the
automatically created default instance available to the constructor
as the <code>this</code> binding
(<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2">E5.1 Section 13.2.2</a>).
This allows a Proxy object to be returned from a constructor as the result
of a constructor call.</p><p>It's also possible to initialize the <code>this</code> object normally, and
then wrap it behind a proxy (see
<a href="https://github.com/svaarala/duktape/blob/master/tests/ecmascript/test-bi-proxy-in-constructor.js">test-bi-proxy-in-constructor.js</a>):</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">MyConstructor</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// Initialize 'this' normally</span>
<span class="normal">    </span><span class="keyword">this</span><span class="symbol">.</span><span class="normal">foo </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'bar'</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// Wrap it behind a proxy</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Proxy</span><span class="symbol">(</span><span class="keyword">this</span><span class="symbol">,</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// proxy traps</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="keyword">var</span><span class="normal"> obj </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">MyConstructor</span><span class="symbol">();</span>
</pre><h2 class="sectiontitle" id="virtualproperties.3">Mechanisms not supported by Duktape <a class="sectionlink" href="#virtualproperties.3">§</a></h2><p>There are various non-standard mechanisms for property virtualization.
These are <b>not supported</b> by Duktape:</p><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch">Object.prototype.watch()</a></li>
</ul><hr/><h1 class="sectiontitle" id="internalproperties">Internal properties <a class="sectionlink" href="#internalproperties">§</a></h1><p>Duktape supports non-standard <b>internal properties</b> which are
essentially hidden from user code.  They can only be accessed by a
direct property read/write, and are never enumerated, serialized by
<code>JSON.stringify()</code> or returned from built-in functions such
as <code>Object.getOwnPropertyNames()</code>.</p><p>Duktape uses internal properties for various implementation specific
purposes, such as storing an object's finalizer reference, the internal
value held by <code>Number</code> and <code>Date</code>, etc.  User code
can also use internal properties for its own purposes, e.g. to
store "hidden state" in objects, as long as the property names never
conflict with current or future Duktape internal keys (this is ensured
by the naming convention described below).  User code should never try
to access Duktape's internal properties: the set of internal properties
used can change arbitrarily between versions.</p><p>Internal properties are distinguished from other properties by the
property key: if the byte representation of a property key begins with
a <code>0xFF</code> byte Duktape automatically treats the property as an
internal property.  Such a string is referred to as an <b>internal string</b>.
The initial byte makes the key invalid UTF-8 (even invalid extended UTF-8),
which ensures that (1) internal properties never conflict with normal Unicode
property names and that (2) ordinary Ecmascript code cannot accidentally access
them.  The initial prefix byte is often represented by an underscore in
documentation for readability, e.g. <code>_Value</code> is used instead
of <code>\xFFValue</code>.</p><p>The following naming convention is used.  The convention ensures that
Duktape and user internal properties never conflict:</p><table>
<tr>
<th>Type</th>
<th>Example (C)</th>
<th>Bytes</th>
<th>Description</th>
</tr>
<tr>
<td>Duktape</td>
<td><code>"\xFF" "Value"</code></td>
<td><code>ff 56 61 6c 75 65</code></td>
<td>First character is always uppercase, followed by <code>[a-z0-9_]*</code>.</td>
</tr>
<tr>
<td>User</td>
<td><code>"\xFF" "myprop"</code></td>
<td><code>ff 6d 79 70 72 6f 70</code></td>
<td>First character must not be uppercase to avoid conflict with
current or future Duktape keys.</td>
</tr>
<tr>
<td>User</td>
<td><code>"\xFF\xFF" &lt;arbitrary&gt;</code></td>
<td><code>ff ff &lt;arbitrary&gt;</code></td>
<td>Double <code>0xFF</code> prefix followed by arbitrary data.</td>
</tr>
</table><p>In some cases the internal key needed by user code is not static, e.g.
it can be dynamically generated by serializing a pointer or perhaps the
bytes are from an external source.  In this case it is safest to use
two <code>0xFF</code> prefix bytes as the example above shows.</p><div class="note">
Note that the <code>0xFF</code> prefix cannot be expressed as a valid
Ecmascript string.  For example, the internal string <code>\xFFxyz</code>
would appear as the bytes <code>ff 78 79 7a</code> in memory, while the
Ecmascript string <code>"\u00ffxyz"</code> would be represented as the
CESU-8 bytes <code>c3 bf 78 79 7a</code> in memory.
</div><p>Creating an internal string is easy from C code:</p><pre class="c-code"><span class="comment">/* Create an internal string, which can then be used to read/write internal</span>
<span class="comment"> * properties, and can be passed on to Ecmascript code like any other string.</span>
<span class="comment"> * Terminating a string literal after a hex escape is safest to avoid some</span>
<span class="comment"> * ambiguous cases like "\xffab".</span>
<span class="comment"> */</span>
<span class="function">duk_push_string</span><span class="symbol">(</span><span class="normal">ctx</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\x</span><span class="string">ff"</span><span class="normal"> </span><span class="string">"myprop"</span><span class="symbol">);</span>
</pre><p>For more discussion on C string hex escaping, see
<a href="https://github.com/svaarala/duktape/blob/master/misc/c_hex_esc.c">c_hex_esc.c</a>.</p><p>Internal strings can also be created from Ecmascript code if one has access
to e.g. the Buffer constructor or <code>Duktape.dec()</code> (this must be considered
in sandboxing):</p><pre class="ecmascript-code"><span class="comment">// Using Duktape.Buffer()</span>
<span class="keyword">var</span><span class="normal"> buf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Buffer</span><span class="symbol">(</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">buf</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">255</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> key1 </span><span class="symbol">=</span><span class="normal"> buf </span><span class="symbol">+</span><span class="normal"> </span><span class="string">'myprop'</span><span class="symbol">;</span>

<span class="comment">// Using Duktape.dec()</span>
<span class="keyword">var</span><span class="normal"> key2 </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'hex'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'ff6d7970726f70'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// \xFFmyprop</span>
</pre><p>There's no special access control for internal properties: if user code has
access to the property name (string), it can read/write the property value.
Any code with the ability to create or use buffers can potentially create an
internal string by converting a buffer into a string.  However, standard Ecmascript
code with no access to buffer values or ability to create them cannot create internal
strings (or any invalid UTF-8 strings in general).  When sandboxing, ensure that
the sandboxed code has no access to the <code>Duktape</code> built-in or any
buffer values.</p><p>As a concrete example, the internal value of a <code>Date</code> can be
accessed as follows:</p><pre class="ecmascript-code"><span class="comment">// Print the internal timestamp of a Date instance.  User code should NEVER</span>
<span class="comment">// actually do this because the internal properties may change between</span>
<span class="comment">// versions in an arbitrary manner!</span>

<span class="keyword">var</span><span class="normal"> key </span><span class="symbol">=</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">dec</span><span class="symbol">(</span><span class="string">'hex'</span><span class="symbol">,</span><span class="normal"> </span><span class="string">'ff56616c7565'</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// \xFFValue</span>
<span class="keyword">var</span><span class="normal"> dt </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Date</span><span class="symbol">(</span><span class="number">123456</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="string">'internal value is:'</span><span class="symbol">,</span><span class="normal"> dt</span><span class="symbol">[</span><span class="normal">key</span><span class="symbol">]);</span><span class="normal">  </span><span class="comment">// prints 123456</span>
</pre><hr/><h1 class="sectiontitle" id="threading">Threading <a class="sectionlink" href="#threading">§</a></h1><p>Duktape supports a limited form of multithreading:</p><ul>
<li>A particular Duktape heap created with <code>duk_create_heap()</code> is
    single threaded: only one native thread can execute code in the heap at a
    time.  The native thread can change over time, as long as two native threads
    are not active at the same time in the same Duktape heap.</li>
<li>Duktape heaps are completely isolated from each other.  Multiple native
    threads can execute code at the same time, as long as there is only one
    active native thread per Duktape heap.</li>
</ul><p>For some background, a Duktape heap is a single memory management region
regardless of how many Duktape threads exist in the heap (don't confuse native
threads and Duktape threads).  Because the Duktape threads in a heap can share
object references, multithreading support would need synchronization for garbage
collection and all object handling.  Synchronization would be a major
portability issue, so a practical approach is to limit a Duktape heap to be
single threaded.  Duktape heaps don't share anything so there are no threading
limitations between them as a general rule.  However, when some platform features
are not available (such as variadic preprocessor macros or re-entrant system calls)
there are some limitations.</p><p>See
<a href="https://github.com/svaarala/duktape/blob/master/doc/threading.rst">threading.rst</a>
for a detailed discussion of threading limitations and best practices.</p><hr/><h1 class="sectiontitle" id="sandboxing">Sandboxing <a class="sectionlink" href="#sandboxing">§</a></h1><p>Sandboxed environments allow execution of untrusted code with two broad
goals in mind:</p><ul>
<li>Security: prevent untrusted code from doing unsafe operations such as
    accessing memory directly, causing segfaults, etc.</li>
<li>Availability: prevent untrusted code from hogging resources, e.g.
    consuming all available memory or entering an infinite loop.</li>
</ul><p>Duktape provides mechanisms to achieve these goals for untrusted Ecmascript
code.  All C code is expected to be trusted.
See
<a href="https://github.com/svaarala/duktape/blob/master/doc/sandboxing.rst">sandboxing.rst</a>
for a detailed discussion of how to implement sandboxing.</p><div class="note">
Sandboxing support in Duktape 1.1 is still a work in progress.
</div><hr/><h1 class="sectiontitle" id="performance">Performance <a class="sectionlink" href="#performance">§</a></h1><p>This section discussed Duktape specific performance characteristics and
provides some hints to avoid Duktape specific performance pitfalls.</p><h2 class="sectiontitle" id="performance-overview">Performance overview <a class="sectionlink" href="#performance-overview">§</a></h2><p>Duktape is an interpreted engine with currently no JIT support.  It uses
reference counting which makes memory usage tight at the cost of some execution
performance.  Overall Duktape performance should be similar to other interpreted
languages.  However, up to Duktape 1.1 there has been very little performance
work and Duktape is significantly slower than e.g. Lua right now.  Performance
work has been scheduled for spring 2015.</p><h2 class="sectiontitle" id="performance-characteristics">Duktape performance characteristics <a class="sectionlink" href="#performance-characteristics">§</a></h2><h3 class="sectiontitle" id="performance-characteristics.1">String interning <a class="sectionlink" href="#performance-characteristics.1">§</a></h3><p>Strings are
<a href="http://en.wikipedia.org/wiki/String_interning">interned</a>: only
a single copy of a certain string exists at any point in time.  Interning
a string involves hashing the string and looking up a global string table
to see whether the string is already present.  If so, a pointer to the
existing string is returned; if not, the string is inserted into the string
table, potentially involving a string table resize.  While a string remains
reachable, it has a unique and a stable pointer which allows byte-by-byte
string comparisons to be converted to simple pointer comparisons.  Also,
string hashes are computed during interning which makes the use of string
keys in internal hash tables efficient.</p><p>There are many downsides also.  Strings cannot be modified in-place but
a copy needs to be made for every modification.  For instance, repeated
string concatenation creates a temporary value for each intermediate string
which is especially bad if a result string is built one character at a time.
Duktape internal primitives, such as string case conversion and array
<code>join()</code>, try to avoid these downsides by minimizing the number
of temporary strings created.</p><h3 class="sectiontitle" id="performance-characteristics.2">String memory representation and the string cache <a class="sectionlink" href="#performance-characteristics.2">§</a></h3><p>The internal memory representation for strings is extended UTF-8, which
represents each ASCII character with a single byte but uses two or more
bytes to represent non-ASCII characters.  This reduces memory footprint for
most strings and makes strings easy to interact with in C code.  However,
it makes random access expensive for non-ASCII strings.  Random access is
needed for operations such as extracting a substring or looking up a
character at a certain character index.</p><p>Duktape automatically detects pure ASCII strings (based on the fact that
their character and byte length are identical) and provides efficient random
access to such strings.</p><p>However, when a string contains non-ASCII characters a <b>string cache</b>
is used to resolve a character index to an internal byte index.  Duktape
maintains a few (internal define <code>DUK_HEAP_STRCACHE_SIZE</code>,
currently 4) string cache entries which remember the last byte offset and
character offset for recently accessed strings.  Character index lookups
near a cached character/byte offset can be efficiently handled by scanning
backwards or forwards from the cached location.  When a string access cannot
be resolved using the cache, the string is scanned either from the beginning
or the end, which is obviously very expensive for large strings.  The cache
is maintained with a very simple LRU mechanism and is transparent to both
Ecmascript and C code.</p><p>The string cache makes simple loops like the following efficient:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> inp</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">inp</span><span class="symbol">.</span><span class="function">charCodeAt</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="cbracket">}</span>
</pre><p>When random accesses are made from here and there to multiple strings,
the strings may very easily fall out of the cache and become expensive
at least for longer strings.</p><p>Note that the cache never maintains more than one entry for each
string, so the following would be very inefficient:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> inp</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// Accessing the string alternatively from beginning and end will</span>
<span class="normal">    </span><span class="comment">// have a major performance impact.</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">inp</span><span class="symbol">.</span><span class="function">charCodeAt</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">inp</span><span class="symbol">.</span><span class="function">charCodeAt</span><span class="symbol">(</span><span class="normal">n </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> i</span><span class="symbol">));</span>
<span class="cbracket">}</span>
</pre><p>As mentioned above, these performance issues are avoided entirely for
ASCII strings which behave as one would expect.  More generally, Duktape
provides fast paths for ASCII characters and pure ASCII strings in internal
algorithms whenever applicable.  This applies to algorithms such as case
conversion, regexp matching, etc.</p><h3 class="sectiontitle" id="performance-characteristics.3">Buffer accesses <a class="sectionlink" href="#performance-characteristics.3">§</a></h3><p>
There is a fast path for reading and writing numeric indices of plain buffer
values, e.g. <code>x = buf[123]</code> or <code>buf[123] = x</code>.  The
fast path avoids coercing the index to a string (here <code>"123"</code>)
before attempting a lookup.</p><p>This fast path is not active when the base value is a Buffer object.</p><h3 class="sectiontitle" id="performance-characteristics.4">Object/array storage <a class="sectionlink" href="#performance-characteristics.4">§</a></h3><p>Object properties are stored in a linear key/value list which provides
stable ordering (insertion order).  When an object has enough properties
(internal define <code>DUK_HOBJECT_E_USE_HASH_LIMIT</code>, currently 32),
a hash lookup table is also allocated to speed up property lookups.  Even
in this case the key ordering is retained which is a practical requirement
for an Ecmascript implementation.  The hash part is avoided for most objects
because it increases memory footprint and doesn't significantly speed up
property lookups for very small objects.</p><p>For most objects property lookup thus involves a linear comparison
against the object's property table.  Because properties are kept in the
property table in their insertion order, properties added earlier are
slightly faster to access than those added later.  When the object grows
large enough to gain a hash table this effect disappears.</p><p>Array elements are stored in a special "array part" to reduce memory
footprint and to speed up access.  Accessing an array with a numeric index
officially first coerces the number to a string (e.g. <code>x[123]</code>
to <code>x["123"]</code>) and then does a string key lookup; when an object
has an array part no temporary string is actually created in most cases.</p><p>The array part can be "sparse", i.e. contain unmapped entries.  Duktape
occasionally rechecks the density of the array part, and it it becomes too
sparse the array part is abandoned (current limit is roughly: if fewer than
25% of array part elements are mapped, the array part is abandoned).  The
array entries are then converted to ordinary object properties, with every
mapped array index converted to an explicit string key (such as
<code>"123"</code>), which is relatively expensive.  If an array part has
once been abandoned, it is never recreated even if the object would be dense
enough to warrant an array part.</p><p>Elements in the array part are required to be plain properties (not
accessors) and have default property attributes (writable, enumerable,
and configurable).  If any element deviates from this, the array part is
again abandoned and array elements converted to ordinary properties.</p><h3 class="sectiontitle" id="performance-characteristics.5">Identifier access <a class="sectionlink" href="#performance-characteristics.5">§</a></h3><p>Duktape has two modes for storing and accessing identifiers (function
arguments, local variables, function declarations): a fast path and a slow
path.  The fast path is used when an identifier can be bound to a virtual
machine register, i.e., a fixed index in a virtual stack frame allocated
for a function.  Identifier access is then simply an array lookup.  The
slow path is used when the fast path cannot be safely used; identifier
accesses are then converted to explicit property lookups on either
external or internal objects, which is more than an order of magnitude
slower.</p><p>To keep identifier accesses in the fast path:</p><ul>
<li>Execute (almost all) inside Ecmascript functions, not in the top-level
    program or eval code: global/eval code never uses fast path identifier
    accesses (however, function code inside global/eval does)</li>
<li>Store frequently accessed values in local variables instead of looking
    them up from the global object or other objects</li>
</ul><h3 class="sectiontitle" id="performance-characteristics.6">Enumeration <a class="sectionlink" href="#performance-characteristics.6">§</a></h3><p>When an object is enumerated, with either the <code>for-in</code> statement
or <code>Object.keys()</code>, Duktape first traverses the target object and its
prototype chain and forms an internal enumeration object, which contains all
the enumeration keys as strings.
In particular, all array indices (or character indices in case of
strings) are converted and interned into string values before enumeration and
they remain interned until the enumeration completes.  This can be memory
intensive especially if large arrays or strings are enumerated.</p><p>Note, however, that iterating a string or an array with <code>for-in</code>
and expecting the array elements or string indices to be enumerated in an
ascending order is non-portable.  Such behavior, while guaranteed by many
implementations including Duktape, is not guaranteed by the Ecmascript
standard.</p><h3 class="sectiontitle" id="performance-characteristics.7">Function features <a class="sectionlink" href="#performance-characteristics.7">§</a></h3><p>Ecmascript has a lot of features which make function entry and execution
quite expensive.  The general goal of the Duktape Ecmascript compiler is to
avoid all the troublesome features for most functions while providing full
compatibility for the rest.</p><p>An ideal compiled function has all its variables and functions bound to
virtual machine registers to allow fast path identifier access, avoids
creation of the <code>arguments</code> object on entry, avoids creation of
explicit lexical environment records upon entry and during execution, and
avoids storing any lexical environment related control information such as
internal identifier-to-register binding tables.</p><p>The following features have a significant impact on execution performance:</p><ul>
<li>access to the <code>arguments</code> object: requires creation of an
    expensive object upon function entry in case it is accessed</li>
<li>a direct call to <code>eval()</code>: requires initialization of
    the <code>arguments</code> and full identifier binding information
    needs to be retained in case evaluated code needs it</li>
<li>global and eval code in general: identifiers are never bound to
    virtual machine registers but use explicit property lookups instead</li>
</ul><p>The following features have a more moderate impact:</p><ul>
<li><code>try-catch-finally</code> statement: the dynamic binding required
    by the catch variable is relatively expensive</li>
<li><code>with</code> statement: the object binding required is relatively
    expensive</li>
<li>use of bound functions, i.e. functions created with
    <code>Function.prototype.bind()</code>: function invocation is slowed
    down by handling of bound function objects and argument shuffling</li>
<li>more than about 250 formal arguments, literals, and active temporaries:
    causes bytecode to use register shuffling</li>
</ul><p>To avoid these, isolate performance critical parts into separate minimal
functions which avoid using the features mentioned above.</p><h2 class="sectiontitle" id="performance.3">Minimize use of temporary strings <a class="sectionlink" href="#performance.3">§</a></h2><p>All temporary strings are interned.  It is particularly bad to accumulate
strings in a loop:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="string">''</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">1024</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    t </span><span class="symbol">+=</span><span class="normal"> </span><span class="string">'x'</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>This will intern 1025 strings.  Execution time is <code>O(n^2)</code>
where <code>n</code> is the loop limit.  It is better to use a temporary
array instead:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">1024</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    t</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="string">'x'</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="normal">t </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="function">join</span><span class="symbol">(</span><span class="string">''</span><span class="symbol">);</span>
</pre><p>Here, <code>x</code> will be interned once into a function constant, and
each array entry simply refers to the same string, typically costing only 8
bytes per array entry.  The final <code>Array.prototype.join()</code> avoids
unnecessary interning and creates the final string in one go.</p><h2 class="sectiontitle" id="performance.4">Avoid large non-ASCII strings if possible <a class="sectionlink" href="#performance.4">§</a></h2><p>Avoid operations which require access to a random character offset inside
a large string containing one or more non-ASCII characters.  Such accesses
require use of the internal "string cache" and may, in the worst case, require
a brute force scanning of the string to find the correct byte offset
corresponding to the character offset.</p><p>Case conversion and other Unicode related operations have fast paths for
ASCII codepoints but fall back to a slow path for non-ASCII codepoints.  The
slow path is size optimized, not speed optimized, and often involve linear
range matching.</p><h2 class="sectiontitle" id="performance.5">Iterate over plain buffer values, not Buffer objects <a class="sectionlink" href="#performance.5">§</a></h2><p>Plain buffer values have a fast path when buffer contents are accessed
with numeric indices.  When dealing with a value which is potentially a
Buffer object (not a plain buffer), get the plain buffer before iteration:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">;</span>

<span class="comment">// Buffer object, typeof is 'object'</span>
<span class="keyword">var</span><span class="normal"> bufferValue </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="function">Buffer</span><span class="symbol">(</span><span class="string">'foo'</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> bufferValue</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// 'object'</span>

<span class="comment">// Get plain buffer, if already plain, no harm</span>
<span class="normal">b </span><span class="symbol">=</span><span class="normal"> bufferValue</span><span class="symbol">.</span><span class="function">valueOf</span><span class="symbol">();</span>
<span class="function">print</span><span class="symbol">(</span><span class="keyword">typeof</span><span class="normal"> b</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// always 'buffer'</span>

<span class="normal">n </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span><span class="normal">  </span><span class="comment">// fast path buffer access</span>
<span class="cbracket">}</span>
</pre><p>When creating buffers, note that <code>new Duktape.Buffer(x)</code> always
creates a Buffer object, while <code>Duktape.Buffer(x)</code> returns a plain
buffer value.  This mimics how Ecmascript <code>new String()</code> and
<code>String()</code> work.  Plain buffers should be preferred whenever
possible.</p><h2 class="sectiontitle" id="performance.6">Avoid sparse arrays when possible <a class="sectionlink" href="#performance.6">§</a></h2><p>If an array becomes too sparse at any point, Duktape will abandon the
array part permanently and convert array properties to explicit string keyed
properties.  This may happen for instance if an array is initialized with a
descending index:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> arr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1000</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">--)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// bad: first write will abandon array part permanently</span>
<span class="normal">    arr</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> i </span><span class="symbol">*</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>Right after the first array write the array part would contain 1001
entries with only one mapped array element.  The density of the array would
thus be less than 0.1%.  This is way below the density limit for abandoning
the array part, so the array part is abandoned immediately.  At the end the
array part would be 100% dense but will never be restored.  Using an ascending
index fixes the issue:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> arr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="number">1000</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    arr</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> i </span><span class="symbol">*</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><p>Setting the <code>length</code> property of an array manually does not,
by itself, cause an array part to be abandoned.  To simplify a bit, the array
density check compares the number of mapped elements relative to the highest
used element (actually allocated size).  The <code>length</code> property does
not affect the check.  Although setting an array length beforehand may
effectively pre-allocate an array in some implementations, it has no such
effect in Duktape, at least at the moment.  For example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> arr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="normal">arr</span><span class="symbol">.</span><span class="normal">length </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1001</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// array part not abandoned, but no speedup in Duktape</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="number">1000</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    arr</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> i </span><span class="symbol">*</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="cbracket">}</span>
</pre><h2 class="sectiontitle" id="performance.7">Iterate arrays with explicit indices, not a "for-in" <a class="sectionlink" href="#performance.7">§</a></h2><p>Because the internal enumeration object contains all (used) array
indices converted to string values, avoid <code>for-in</code> enumeration
of at least large arrays.  As a concrete example, consider:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> a </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">1000000</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  a</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="keyword">in</span><span class="normal"> a</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">// Before this loop is first entered, a million strings ("0", "1",</span>
<span class="normal">  </span><span class="comment">// ..., "999999") will be interned.</span>
<span class="normal">  </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="cbracket">}</span>
<span class="comment">// The million strings become garbage collectable only here.</span>
</pre><p>The internal enumeration object created in this example would contain a
million interned string keys for "0", "1", ..., "999999".  All of these keys
would remain reachable for the entire duration of the enumeration.  The
following code would perform much better (and would be more portable, as it
makes no assumptions on enumeration order):</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> a </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">[];</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">1000000</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  a</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="keyword">var</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="cbracket">}</span>
</pre><h2 class="sectiontitle" id="performance.8">Minimize top-level global/eval code <a class="sectionlink" href="#performance.8">§</a></h2><p>Identifier accesses in global and eval code always use slow path instructions
to ensure correctness.  This is at least a few orders of magnitude slower than
the fast path where identifiers are mapped to registers of a function
activation.</p><p>So, this is slow:</p><pre class="ecmascript-code"><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">100</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="cbracket">}</span>
</pre><p>Each read and write of <code>i</code> will be an explicit environment
record lookup, essentially a property lookup from an internal environment
record object, with the string key <code>i</code>.</p><p>Optimize by putting most code into a function:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">main</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">var</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">100</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
<span class="function">main</span><span class="symbol">();</span>
</pre><p>Here, <code>i</code> will be mapped to a function register, and each
access will be a simple register reference (basically a pointer to a
tagged value), which is much faster than the slow path.</p><p>If you don't want to name an explicit function, use:</p><pre class="ecmascript-code"><span class="symbol">(</span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">100</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">print</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">)();</span>
</pre><p>Eval code provides an implicit return value which also has a performance
impact.  Consider, for instance, the following:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> res </span><span class="symbol">=</span><span class="normal"> </span><span class="function">eval</span><span class="symbol">(</span><span class="string">"if (4 &gt; 3) { 'foo'; } else { 'bar'; }"</span><span class="symbol">);</span>
<span class="function">print</span><span class="symbol">(</span><span class="normal">res</span><span class="symbol">);</span><span class="normal">  </span><span class="comment">// prints 'foo'</span>
</pre><p>To support such code the compiler emits bytecode to store a statement's
implicit return value to a temporary register in case it is needed.  These
instructions slow down execution and increase bytecode size unnecessarily.</p><h2 class="sectiontitle" id="performance.9">Prefer local variables over external ones <a class="sectionlink" href="#performance.9">§</a></h2><p>When variables are bound to virtual machine registers, identifier lookups
are much faster than using explicit property lookups on the global object or
on other objects.</p><p>When an external value or function is required multiple times, copy it to
a local variable instead:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">slow</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// 'x.length' is an explicit property lookup and happens on every loop</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// 'print' causes a property lookup to the global object</span>
<span class="normal">        </span><span class="function">print</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">fast</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">length</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">var</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> print</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// every access in the loop now happens through register-bound identifiers</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">p</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
</pre><p>Use such optimizations only where it matters, because they often reduce
code readability.</p><hr/><h1 class="sectiontitle" id="memoryusage">Memory usage <a class="sectionlink" href="#memoryusage">§</a></h1><p>Duktape allocates memory on demand and doesn't require a pre-allocated heap.
When you create a heap on a 32-bit system, Duktape needs about 46kB for the
built-in Ecmascript objects (about 22kB with
<a href="#memory-constrained-options">low memory options</a>).  Additional
memory is then allocated as needed for executing application scripts.
Reference counting ensures there is very little unused allocated memory, the
only exception being objects which participate in reference loops; these are
collected eventually by mark-and-sweep.</p><p>The memory allocations needed by Duktape fall into two basic categories.
First, there are a lot of small allocations between roughly 16 to 128 bytes
which are needed for strings, buffers, objects, object property tables, etc.
Second, there are much fewer larger allocations needed for e.g. Ecmascript
function bytecode, large strings and buffers, value stacks, the global string
table, and the Duktape heap object.</p><p>For most systems memory usage or the memory allocation pattern is not an
issue.  On low memory environments, e.g. less than 1MB of system RAM, you may
want to use a custom allocator to optimize memory usage.  A pool-based
allocator deals well with the small allocation churn without fragmentation
issues.  The downside is that you need to tune the memory pool sizes to match
the concrete allocation patterns.</p><p>See <a href="#memory-constrained-options">low memory options</a> and
<a href="https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst">low-memory.rst</a>
for more discussion on what low memory features exists and how to tune the
memory pools for low memory systems.</p><hr/><h1 class="sectiontitle" id="compiling">Compiling <a class="sectionlink" href="#compiling">§</a></h1><h2 class="sectiontitle" id="compiling.1">Overview <a class="sectionlink" href="#compiling.1">§</a></h2><p>Duktape doesn't have an official Makefile or a build script: given the
number of different portability targets, maintaining an official build
script would be difficult.  Instead, you should add Duktape to your existing
build process in whatever way is most natural.</p><p>Duktape is compiled with a C or C++ compiler (C99 is recommended)
and then linked to your program in some way; the exact details vary between
platforms and toolchains.  For example, you can:</p><ul>
<li>Compile Duktape together with your program without an explicit linking
    step.</li>
<li>Compile Duktape as a static library, and link the static library with
    your program.</li>
<li>Compile Duktape as a dynamic library, and link the dynamic library with
    your program (you'll need <code>DUK_OPT_DLL_BUILD</code>).</li>
</ul><p>There are two alternative distribution formats for the Duktape source:
a single source file and separate source files.  The single source file
version consists of <code>duktape.h</code> and <code>duktape.c</code>.
The separate source files version consists of <code>duktape.h</code> and
a set of separate source files.   The single source file version is preferred,
but separate files work better with some toolchains.</p><p>All Duktape API functions are potentially macros, and the implementation
of a certain API primitive may change between a macro and an actual function
even between compatible releases.  This has two implications:</p><ul>
<li><b>Include <code>duktape.h</code> in application code</b>.  This is
    good practice in general, but without the header your compiler will
    incorrectly assume that all Duktape API functions are actual functions
    which will cause linking to fail.</li>
<li><b>Compile Duktape and your application with the exactly same Duktape
    version</b>.  Even compatible versions may be binary incompatible
    because a function was changed into a macro or vice versa.</li>
</ul><p>Duktape has many features which can be controlled during compilation,
see feature options below.  Some options after binary compatibility of
Duktape and the application.  Because of this:</p><ul>
<li><b>Use the same feature options and the same compiler when compiling
    Duktape and your application</b>.  This is especially important when
    Duktape is compiled as a library in a separate step.</li>
</ul><h2 class="sectiontitle" id="compiling.2">Recommended compiler options <a class="sectionlink" href="#compiling.2">§</a></h2><p>If you compile Duktape with no compiler options, Duktape will detect the
compiler and the platform automatically and select defaults appropriate in
most cases.  Recommended compiler options (for GCC/clang, use similar options
in your compiler):</p><ul>
<li><code>-std=c99</code>: recommended to ensure C99 semantics
    which improve C type detection and allows Duktape to use variadic
    macros</li>
<li><code>-Os</code>: optimize for smallest footprint, which is usually
    desired when embedding Duktape</li>
<li><code>-fomit-frame-pointer</code>: omit frame pointer, further reduces
    footprint but may interfere with debugging (leave out from debug builds)</li>
<li><code>-fstrict-aliasing</code>: use strict aliasing rules, Duktape
    is compatible with these and they improve the resulting C code</li>
<li><code>-DDUK_OPT_DLL_BUILD</code>: needed when Duktape is built as a DLL
    (the option is needed for both Duktape and application build)</li>
</ul><p>If you're using Duktape on a platform where Duktape's automatic feature
detection doesn't (yet) work, you may need to force a specific byte order or
alignment requirements with feature options described below.</p><h2 class="sectiontitle" id="compiling.3">Duktape feature defaults <a class="sectionlink" href="#compiling.3">§</a></h2><p>Duktape feature defaults are, at a high level:</p><ul>
<li>Full Ecmascript E5/E5.1 compliance
    (including the optional 
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-B">Annex B</a>
    features), except for intentional real world compatibility deviations
    (see <a href="#custombehavior">Custom behavior</a>)</li>
<li>Some <a href="#es6features">features borrowed from ES6</a></li>
<li>Packed value representation (8 bytes per value) when available,
    unpacked value representation (usually bytes per value) when not</li>
<li>Reference counting and mark-and-sweep garbage collection</li>
<li>Full error messages and tracebacks</li>
<li>No debug printing, no asserts, etc</li>
</ul><p>Usually these automatic defaults are OK.  If you're working on a constrained
platform, you may need to add specific options to reduce memory footprint or to
minimize garbage collection pauses.</p><h2 class="sectiontitle" id="compiling.4">Feature options (DUK_OPT_xxx) <a class="sectionlink" href="#compiling.4">§</a></h2><p>If you wish to modify the defaults, you can provide feature options in the
form of <code>DUK_OPT_xxx</code> compiler defines.  These will be taken into
account by the internal <code>duk_features.h</code> file, which resolves the
final internal features based on feature requests, compiler features, and
platform features.  The full list of feature options is described in
<a href="https://github.com/svaarala/duktape/blob/master/doc/feature-options.rst">feature-options.rst</a>.</p><div class="note">
If you use Duktape feature options, you must define the feature options both
when compiling Duktape and when compiling any application code using the
<code>duktape.h</code> header.  This is necessary because some feature options
affect the binary compatibility of the Duktape API.
</div><p>The table below summarizes the most commonly needed feature options, in no
particular order:</p><table>
<thead>
<tr>
<th>Define</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="definename">DUK_OPT_DLL_BUILD</td>
<td>Build Duktape as a DLL, affects symbol visibility declarations.
    Most concretely, enables <code>__declspec(dllexport)</code> and
    <code>__declspec(dllimport)</code> on Windows builds.  This option
    must be used also for application build when Duktape is linked as
    a DLL (otherwise <code>__declspec(dllimport)</code> won't be used).</td>
</tr>
<tr>
<td class="definename">DUK_OPT_NO_PACKED_TVAL</td>
<td>Don't use the packed 8-byte internal value representation even if otherwise
    possible.  The packed representation has more platform/compiler portability
    issues than the unpacked one.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_FORCE_ALIGN</td>
<td>Use <code>-DDUK_OPT_FORCE_ALIGN=4</code> or <code>-DDUK_OPT_FORCE_ALIGN=8</code>
    to force a specific struct/value alignment instead of relying on Duktape's
    automatic detection.  This shouldn't normally be needed.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_FORCE_BYTEORDER</td>
<td>Use this to skip byte order detection and force a specific byte order:
    <code>1</code> for little endian, <code>2</code> for ARM "mixed" endian
    (integers little endian, IEEE doubles mixed endian), <code>3</code> for
    big endian.  Byte order detection relies on unstandardized platform
    specific header files, so this may be required for custom platforms if
    compilation fails in endianness detection.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_NO_REFERENCE_COUNTING</td>
<td>Disable reference counting and use only mark-and-sweep for garbage collection.
    Although this reduces memory footprint of heap objects, the downside is much
    more fluctuation in memory usage.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_NO_MARK_AND_SWEEP</td>
<td>Disable mark-and-sweep and use only reference counting for garbage collection.
    This reduces code footprint and eliminates garbage collection pauses, but
    objects participating in unreachable reference cycles won't be collected until
    the Duktape heap is destroyed.  In particular, function instances won't be
    collected because they're always in a reference cycle with their default
    prototype object.  Unreachable objects are collected if you break reference
    cycles manually (and are always freed when a heap is destroyed).</td>
</tr>
<tr>
<td class="definename">DUK_OPT_NO_VOLUNTARY_GC</td>
<td>Disable voluntary periodic mark-and-sweep collection.  A mark-and-sweep
    collection is still triggered in an out-of-memory condition.  This option
    should usually be combined with reference counting, which collects all
    non-cyclical garbage.  Application code should also request an explicit
    garbage collection from time to time when appropriate.  When this option
    is used, Duktape will have no garbage collection pauses in ordinary use,
    which is useful for timing sensitive applications like games.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_TRACEBACK_DEPTH</td>
<td>Override default traceback collection depth.  The default is currently 10.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_NO_FILE_IO</td>
<td>Disable use of ANSI C file I/O which might be a portability issue on some
    platforms.  Causes <code>duk_eval_file()</code> to throw an error,
    makes built-in <code>print()</code> and <code>alert()</code> no-ops,
    and suppresses writing of a panic message to <code>stderr</code> on panic.
    This option does not suppress debug printing so don't enable debug printing
    if you wish to avoid I/O.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_PANIC_HANDLER(code,msg)</td>
<td>Provide a custom panic handler, see detailed description below.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_SELF_TESTS</td>
<td>Perform run-time self tests when a Duktape heap is created.  Catches
    platform/compiler problems which cannot be reliably detected during
    compile time.  Not enabled by default because of the extra footprint.</td>
</tr>
<tr>
<td class="definename">DUK_OPT_ASSERTIONS</td>
<td>Enable internal assert checks.  These slow down execution considerably
    so only use when debugging.</td>
</tr>
</tbody>
</table><h2 class="sectiontitle" id="compiling.5">Suggested feature options for some environments <a class="sectionlink" href="#compiling.5">§</a></h2><h3 class="sectiontitle" id="timing-sensitive-options">Timing sensitive options <a class="sectionlink" href="#timing-sensitive-options">§</a></h3><p>Timing sensitive applications include e.g. games.  For such environments
steady, predictable performance is important, often more important than
absolute performance.  Duktape provides some options to improve use in these
environments; for instance, you can disable automatic mark-and-sweep and rely
on reference counting and manually requested mark-and-sweep for garbage
collection.</p><p>See
<a href="https://github.com/svaarala/duktape/blob/master/doc/timing-sensitive.rst">timing-sensitive.rst</a>
for suggested feature options.</p><h3 class="sectiontitle" id="memory-constrained-options">Memory constrained options <a class="sectionlink" href="#memory-constrained-options">§</a></h3><p>Duktape can work in 256kB flash memory (code footprint) and 96kB system
RAM (including Duktape and a minimal OS), and provides a lot of feature
options to minimize memory footprint.  These feature options are intended
for systems with less than 256kB of system RAM.</p><p>See
<a href="https://github.com/svaarala/duktape/blob/master/doc/low-memory.rst">low-memory.rst</a>
for suggested feature options.</p><h3 class="sectiontitle" id="performance-sensitive-options">Performance sensitive options <a class="sectionlink" href="#performance-sensitive-options">§</a></h3><p>Up to Duktape 1.1 there has been very little performance work.  This will
change in future versions, with performance work scheduled for spring 2015.</p><p>See
<a href="https://github.com/svaarala/duktape/blob/master/doc/performance-sensitive.rst">performance-sensitive.rst</a>
for suggested feature options.</p><h2 class="sectiontitle" id="compiling.6">DUK_OPT_PANIC_HANDLER <a class="sectionlink" href="#compiling.6">§</a></h2><p>The default panic handler will print an error message to stdout unless I/O is
disabled by <code>DUK_OPT_NO_FILE_IO</code>.  It will then call <code>abort()</code>
or cause a segfault if <code>DUK_OPT_SEGFAULT_ON_PANIC</code> is defined.</p><p>This is not always the best behavior for production applications which may
already have better panic recovery mechanisms.  To replace the default panic
handler, see
<a href="https://github.com/svaarala/duktape/blob/master/doc/feature-options.rst">feature-options.rst</a>.</p><h2 class="sectiontitle" id="compiling.7">Memory management alternatives <a class="sectionlink" href="#compiling.7">§</a></h2><p>There are three supported memory management alternatives:</p><ul>
<li><b>Reference counting and mark-and-sweep (default)</b>: heap objects are
    freed immediately when they become unreachable except for objects
    participating in unreachable reference cycles.  Such objects are freed by
    a periodic voluntary, stop the world mark-and-sweep collection.
    Mark-and-sweep is also used as the emergency garbage collector if
    memory allocation fails.</li>
<li><b>Reference counting only</b>: reduces code footprint and eliminates
    garbage collection pauses, but objects in unreachable reference cycles
    are not collected until the Duktape heap is destroyed.  This alternative
    is not recommended unless the reference cycles are not an issue.  See notes
    below.</li>
<li><b>Mark-and-sweep only</b>: reduces code footprint and memory footprint
    (heap headers don't need to store a reference count), but there is more
    memory usage variance than in the default case.  The frequency of voluntary,
    stop the world mark-and-sweep collections is also higher than in the default
    case where reference counting is expected to handle almost all memory
    management.</li>
</ul><p>When using only reference counting it is important to avoid creating
unreachable reference cycles.  Reference cycles are usually easy to avoid in
application code e.g. by using only forward pointers in data structures.  Even
if reference cycles are necessary, garbage collection can be allowed to work
simply by breaking the cycles before deleting the final references to such objects.
For example, if you have a tree structure where nodes maintain references to
both children and parents (creating reference cycles for each node) you could
walk the tree and set the parent reference to <code>null</code> before deleting
the final reference to the tree.</p><p>Unfortunately every Ecmascript function instance is required to be in a
reference loop with an automatic prototype object created for the function.
You can break this loop manually if you wish.  For internal technical reasons,
named function expressions are also in a reference loop; this loop cannot be
broken from user code and only mark-and-sweep can collect such functions.
See <a href="#limitations">Limitations</a>.</p><h2 class="sectiontitle" id="duktape-cplusplus">Using a C++ compiler <a class="sectionlink" href="#duktape-cplusplus">§</a></h2><p>Duktape works with both C and C++ compilers and applications.  You can
compile Duktape and the application with a C or a C++ compiler in any
combination.  Even so, it is recommended to compile both Duktape and the
application with the same compiler (i.e. both with a C compiler or both
with a C++ compiler) and with the same compiler options.</p><p>The <code>duktape.h</code> header contains the necessary glue to make all
of these combinations work.  Specifically, all symbols needed by Duktape
public API are inside a <code>extern "C" { ... }</code> wrapper (active only
if compiled with a C++ compiler).  This ensures that such symbols are defined
and used without C++ name mangling.  Specifically:</p><ul>
<li>When compiling Duktape itself with a C++ compiler, symbols needed by
    Duktape public API are not mangled.  Other Duktape internal symbols will
    be mangled, but are not externally visible and should thus cause no
    problems even if the application is compiled with a C compiler.</li>
<li>When compiling an application with a C++ compiler, the wrapper ensures
    that Duktape public API symbols used by the application are looked up
    without mangling.</li>
</ul><p>If you mix C and C++ compilation, you should do the final linking with the
C++ toolchain.  At least when mixing gcc/g++ you may encounter something like:</p><pre>
$ g++ -c -o duktape.o -Isrc/ src/duktape.c
$ gcc -c -o duk_cmdline.o -Isrc/ examples/cmdline/duk_cmdline.c
$ gcc -o duk duktape.o duk_cmdline.o -lm -lreadline -lncurses
duktape.o:(.eh_frame+0x1ab): undefined reference to `__gxx_personality_v0'
collect2: error: ld returned 1 exit status
</pre><p>One fix is to use <code>g++</code> for linking:</p><pre>
$ g++ -c -o duktape.o -Isrc/ src/duktape.c
$ gcc -c -o duk_cmdline.o -Isrc/ examples/cmdline/duk_cmdline.c
$ g++ -o duk duktape.o duk_cmdline.o -lm -lreadline -lncurses
</pre><p>Because <code>duktape.h</code> selects C/C++ data types needed by
Duktape and also does other feature detection, mixing C and C++ compilers
could theoretically cause the C and C++ compilers to end up with different
active features or data types.  If that were to happen, Duktape and the
application would be binary incompatible (which would be difficult to
diagnose).  This is usually not an issue, but to avoid the potential, compile
Duktape and the application with the same compiler.</p><h2 class="sectiontitle" id="compiling.9">Compiler warnings <a class="sectionlink" href="#compiling.9">§</a></h2><p>Current goal is for the Duktape compile to be clean when:</p><ul>
<li>using a major compiler (e.g. gcc, clang, MSVC, mingw);</li>
<li>the compiler is in C99 mode; and</li>
<li>warnings are enabled (e.g. <code>-Wall</code> in gcc/clang).</li>
</ul><p>There are still some warnings present when you compile with
<code>-Wextra</code> or equivalent option.</p><p>There may be some warnings when compiling with a pre-C99 compiler
(or a C99 compiler without a <code>-std=c99</code> option or similar).</p><hr/><h1 class="sectiontitle" id="portability">Portability <a class="sectionlink" href="#portability">§</a></h1><h2 class="sectiontitle" id="portability.1">Platforms and compilers <a class="sectionlink" href="#portability.1">§</a></h2><p>The table below summarizes the platforms and compilers which Duktape is known
to work on, with portability notes where appropriate.  This is <b>not an exhaustive
list</b> of supported/unsupported platforms, rather a list of what is known to work
(and not to work).  Platform and compiler specific issues are discussed in more
detail below the table.</p><table>
<thead>
<tr>
<th>Operating system</th>
<th>Compiler</th>
<th>Processor</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>x86</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>x64</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>x32</td>
<td>No known issues, use <code>-mx32</code>.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>ARM</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>MIPS</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>SuperH</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>GCC</td>
<td>SPARC</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>Clang</td>
<td>x86</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>Clang</td>
<td>x64</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>Clang</td>
<td>ARM</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>Clang</td>
<td>MIPS</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>TCC</td>
<td>x64</td>
<td>Zero sign issues (see below).</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>Clang</td>
<td>x86</td>
<td>Aliasing issues with clang 3.3 on 64-bit FreeBSD, <code>-m32</code>, and packed <code>duk_tval</code> (see below).</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>Clang</td>
<td>x64</td>
<td>No known issues.</td>
</tr>
<tr>
<td>NetBSD</td>
<td>GCC</td>
<td>x86</td>
<td>No known issues (NetBSD 6.0).  There are some <code>pow()</code> function incompatibilities on NetBSD, but
    there is a workaround for them.</td>
</tr>
<tr>
<td>OpenBSD</td>
<td>GCC</td>
<td>x86</td>
<td>No known issues (FreeBSD 5.4).</td>
</tr>
<tr>
<td>Windows</td>
<td>MinGW</td>
<td>x86</td>
<td><code>-std=c99</code> recommended, only ISO 8601 date format supported (no platform specific format).</td>
</tr>
<tr>
<td>Windows</td>
<td>MinGW-w64</td>
<td>x64</td>
<td><code>-m64</code>, <code>-std=c99</code> recommended, only ISO 8601 date format supported (no platform specific format).</td>
</tr>
<tr>
<td>Windows</td>
<td>MSVC<br/>(Visual Studio Express 2010)</td>
<td>x86</td>
<td>Only ISO 8601 date format supported (no platform specific format).
    Harmless warnings if <code>/Wp64</code> is enabled.</td>
</tr>
<tr>
<td>Windows</td>
<td>MSVC<br/>(Visual Studio Express 2013 for Windows Desktop)</td>
<td>x64</td>
<td>Only ISO 8601 date format supported (no platform specific format).</td>
</tr>
<tr>
<td>Windows</td>
<td>MSVC<br/>(Visual Studio 2010)</td>
<td>x64</td>
<td>Only ISO 8601 date format supported (no platform specific format).
    May require explicit <code>DUK_OPT_NO_PACKED_TVAL</code> with
    Duktape 0.10.0.</td>
</tr>
<tr>
<td>Android</td>
<td>GCC<br/>(Android NDK)</td>
<td>ARM</td>
<td><code>-std=c99</code> required at least on some NDK versions.</td>
</tr>
<tr>
<td>OSX</td>
<td>Clang</td>
<td>x64</td>
<td>Tested on OSX 10.9.2 with XCode.</td>
</tr>
<tr>
<td>Darwin</td>
<td>GCC</td>
<td>x86</td>
<td>No known issues.</td>
</tr>
<tr>
<td>QNX</td>
<td>GCC</td>
<td>x86</td>
<td><code>-std=c99</code> recommended.  Architectures other than x86 should also work.</td>
</tr>
<tr>
<td>AmigaOS</td>
<td>VBCC</td>
<td>M68K</td>
<td>Requires some preprocessor defines, datetime resolution limited to full seconds.</td>
</tr>
<tr>
<td>TOS<br/>(Atari ST)</td>
<td>VBCC</td>
<td>M68K</td>
<td>Requires some preprocessor defines, datetime resolution limited to full seconds.</td>
</tr>
<tr>
<td>Emscripten</td>
<td>Emscripten</td>
<td>n/a</td>
<td>Requires additional options, see below. At least V8/NodeJs works.</td>
</tr>
<tr>
<td>Adobe Flash Runtime</td>
<td>CrossBridge<br/>(GCC-4.2 with Flash backend)</td>
<td>n/a</td>
<td><code>-std=c99</code> recommended, may need <code>-jvmopt=-Xmx1G</code> if running
    32-bit Java.  Tested with <a href="http://adobe-flash.github.io/crossbridge/">CrossBridge</a>
    1.0.1 on 64-bit Windows 7.</td>
</tr>
<tr>
<td>pNaCl</td>
<td>clang</td>
<td>n/a</td>
<td>No known issues.</td>
</tr>
<tr>
<td>Linux</td>
<td>BCC<br/>(Bruce's C compiler)</td>
<td>i386</td>
<td><code>-3</code> and <code>-ansi</code> required; compiles but doesn't link.  This is an
    old compiler useful for portability torture tests (for instance 16-bit <code>int</code> type).</td>
</tr>
</tbody>
</table><h3 class="sectiontitle" id="portability.1.1">Clang <a class="sectionlink" href="#portability.1.1">§</a></h3><p>Clang 3.3 on FreeBSD has some aliasing issues (at least) when using
<code>-m32</code> and when Duktape ends up using a packed <code>duk_tval</code>
value representation type.  You can work around the problem by defining
<code>DUK_OPT_NO_PACKED_TVAL</code> to disable packed value type.  The
problem does not appear in all clang versions.  Duktape self tests cover
this issue (define <code>DUK_OPT_SELF_TESTS</code> when compiling).
See internal test file <code>misc/clang_aliasing.c</code>.</p><h3 class="sectiontitle" id="portability.1.2">MSVC <a class="sectionlink" href="#portability.1.2">§</a></h3><p>The <a href="http://msdn.microsoft.com/en-us/library/yt4xw8fh.aspx"><code>/Wp64</code>
(Detect 64-bit Portability issues)</a> option causes harmless compile warnings when compiling
32-bit code, e.g.:</p><pre>
duk_api.c(2419): warning C4311: 'type cast' : pointer truncation from 'duk_hstring *' to 'duk_uint32_t'
</pre><p>The warnings are caused by Duktape casting 32-bit pointers to 32-bit integers
used by its internal value representation.  These casts would be incorrect in a 64-bit
environment which is reported by the <code>/Wp64</code> option.  When Duktape is
compiled in a 64-bit environment a different value representation is used which
doesn't use these casts at all, so the warnings are not relevant.</p><p>Compilation with <code>/Wall</code> is not clean at the moment.</p><h3 class="sectiontitle" id="portability.1.3">TCC <a class="sectionlink" href="#portability.1.3">§</a></h3><p>TCC has zero sign handling issues; Duktape mostly works but zero sign is
not handled correctly.  This results in Ecmascript non-compliance, for
instance <code>1/-0</code> evaluates to <code>Infinity</code>, not <code>-Infinity</code>
as it should.</p><h3 class="sectiontitle" id="portability.1.4">VBCC (AmigaOS / TOS) <a class="sectionlink" href="#portability.1.4">§</a></h3><p>VBCC doesn't appear to provide OS or processor defines.  To compile for
M68K AmigaOS or TOS you must:</p><ul>
<li>Define <code>__MC68K__</code> manually.</li>
<li>Define either <code>AMIGA</code> or <code>__TOS__</code> manually.</li>
</ul><p>Datetime resolution is limited to full seconds only when using VBCC on
AmigaOS or TOS.</p><h3 class="sectiontitle" id="portability.1.5">Emscripten <a class="sectionlink" href="#portability.1.5">§</a></h3><p>Needs a set of <code>emcc</code> options.  When executed with
V8, the following seem to work:</p><ul>
<li><code>-DEMSCRIPTEN</code>: <b>mandatory option</b>, needed by Duktape
    to detect Emscripten.  Without this Duktape may use unaligned accesses
    which Emscripten does not allow.  This results in odd and inconsistent
    behavior, and is not necessarily caught by Duktape self tests.</li>
<li><code>-std=c99</code></li>
<li><code>-O2</code></li>
<li><code>-s ASM_JS=0</code></li>
<li><code>-s MAX_SETJMPS=1000</code></li>
<li><code>-s OUTLINING_LIMIT=20000</code></li>
</ul><p>Dukweb is compiled using Emscripten, so you can also check out the Duktape
git repository to see how Dukweb is compiled.</p><h2 class="sectiontitle" id="portability.2">Limitations <a class="sectionlink" href="#portability.2">§</a></h2><ul>
<li>Pointer less-than/greater-than comparisons are expected to work like
    pointers were unsigned.  This is incorrect on some platforms.</li>
<li><a href="http://en.wikipedia.org/wiki/Two's_complement">Two's complement</a>
    signed arithmetic is required.  This is not technically guaranteed by ANSI C,
    but there are very few environments where this assumption does not hold.</li>
</ul><h2 class="sectiontitle" id="portability.3">Troubleshooting <a class="sectionlink" href="#portability.3">§</a></h2><ul>
<li>Compile in C mode if possible.  Although C++ compilation now works,
    it isn't as portable as C compilation.</li>
<li>Enable C99 mode if possible (<code>-std=c99</code> or similar).  Type
    detection without C99 is less reliable than with C99.</li>
<li>If Duktape compiles but doesn't seem to work correctly, enable
    self tests with <code>DUK_OPT_SELF_TESTS</code>.  Self tests
    detect some compiler and platform issues which cannot be caught
    compile time.</li>
<li>If the target platform has specific alignment requirements and Duktape
    doesn't autodetect the platform correctly, you may need to provide
    either <code>DUK_OPT_FORCE_ALIGN=4</code> or <code>DUK_OPT_FORCE_ALIGN=8</code>.
    The alignment number should match whatever alignment is needed for IEEE
    doubles and 64-bit integer values.</li>
<li>If compilation fails in endianness detection, Duktape probably doesn't
    (yet) support the platform specific endianness headers of your platform.
    Such headers are unfortunately non-standardized, so endianness detection
    is a common (and usually trivial) portability issue on custom platforms.
    Use <code>DUK_OPT_FORCE_BYTEORDER</code> to force endianness as a workaround.
    If you know how the endianness detection should work on your platform,
    please send an e-mail about the issue or contribute a patch.</li>
<li>Another typical portability issue on new platforms is the Date built-in,
    which requires a few platform specific functions for dealing with date and
    time.  Often existing Date functions are sufficient but platform detection
    in <code>duk_features.h</code> does not yet handle the target platform
    correctly.  This is usually trivial to fix; please contribute a patch if
    you do so.  At other times the platform has no standard time APIs (like
    POSIX).  In this case you'll need to add a few platform specific Date
    functions into <code>duk_bi_date.c</code>, and implement platform detection
    into <code>duk_features.h</code>; again, please contribute a patch if you
    do so.  You can look at <code>duk_bi_date.c</code> for POSIX and Windows
    Date API examples.</li>
</ul><hr/><h1 class="sectiontitle" id="compatibility">Compatibility <a class="sectionlink" href="#compatibility">§</a></h1><p>This section discussed Duktape compatibility with Ecmascript dialects,
extensions, frameworks, and test suites.</p><h2 class="sectiontitle" id="compatibility-e5">Ecmascript E5 / E5.1 <a class="sectionlink" href="#compatibility-e5">§</a></h2><p>The main compatibility goal of Duktape is to be Ecmascript E5/E5.1
compatible.  Current level of compatibility should be quite high.</p><h2 class="sectiontitle" id="compatibility-e6">Ecmascript E6 <a class="sectionlink" href="#compatibility-e6">§</a></h2><p>Duktape borrows a few features from the current Ecmascript E6 draft,
but generally there is no compatibility with E6 yet.</p><h2 class="sectiontitle" id="compatibility-e3">Ecmascript E3 <a class="sectionlink" href="#compatibility-e3">§</a></h2><p>There is no effort to maintain
<a href="http://www.mozilla.org/js/language/E262-3.pdf">Ecmascript E3</a>
compatibility, other than required by the E5/E5.1 specification.</p><h2 class="sectiontitle" id="compatibility-coffeescript">CoffeeScript <a class="sectionlink" href="#compatibility-coffeescript">§</a></h2><p><a href="http://coffeescript.org/">CoffeeScript</a> compiles to
JavaScript which should be compatible with Duktape.  There are no known
compatibility issues.</p><p>Some CoffeeScript examples are included in the distributable.  Simply
run <code>make</code> in <code>examples/coffee/</code>.  For instance,
<code>hello.coffee</code>:</p><pre class="coffeescript-code">
print 'Hello world!'
print 'version: ' + Duktape.version
</pre><p>compiles to:</p><pre class="ecmascript-code"><span class="symbol">(</span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>

<span class="normal">  </span><span class="function">print</span><span class="symbol">(</span><span class="string">'Hello world!'</span><span class="symbol">);</span>

<span class="normal">  </span><span class="function">print</span><span class="symbol">(</span><span class="string">'version: '</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> Duktape</span><span class="symbol">.</span><span class="normal">version</span><span class="symbol">);</span>

<span class="cbracket">}</span><span class="symbol">).</span><span class="function">call</span><span class="symbol">(</span><span class="keyword">this</span><span class="symbol">);</span>
</pre><h2 class="sectiontitle" id="compatibility-coco">Coco <a class="sectionlink" href="#compatibility-coco">§</a></h2><p>Like CoffeeScript, <a href="https://github.com/satyr/coco">Coco</a> compiles to
Javascript.  There are no known issues.</p><h2 class="sectiontitle" id="compatibility-livescript">LiveScript <a class="sectionlink" href="#compatibility-livescript">§</a></h2><p>Like CoffeeScript, <a href="http://livescript.net/">LiveScript</a> compiles to
Javascript.  There are no known issues.</p><h2 class="sectiontitle" id="compatibility-underscorejs">Underscore.js <a class="sectionlink" href="#compatibility-underscorejs">§</a></h2><p><a href="http://underscorejs.org/">Underscore.js</a> provides a lot of
useful utilities to plain Ecmascript.  Duktape passes almost all of Underscore's
test cases, see
<a href="https://github.com/svaarala/duktape/blob/master/doc/underscore-status.rst">underscore-status.rst</a>
for current compatibility status.</p><h2 class="sectiontitle" id="compatibility-test262">Test262 <a class="sectionlink" href="#compatibility-test262">§</a></h2><p><a href="http://test262.ecmascript.org/">test262</a> is a test suite for
testing E5.1 compatibility, although it includes also tests outside of standard E5.1.
Duktape passes almost all of test262 cases, see
<a href="https://github.com/svaarala/duktape/blob/master/doc/test262-status.rst">test262-status.rst</a>
for current compatibility status.</p><h2 class="sectiontitle" id="compatibility-asmjs">Asm.js <a class="sectionlink" href="#compatibility-asmjs">§</a></h2><p><a href="http://asmjs.org/spec/latest/">asm.js</a> is a
"strict subset of JavaScript that can be used as a low-level, efficient
target language for compilers".  As a subset of JavaScript, functions using
asm.js type annotations should be fully compatible with Duktape.  However,
Duktape has no specific support for asm.js and won't optimize asm.js code.
In fact, asm.js code will generate unnecessary bytecode and execute slower
than normal Ecmascript code.  The <code>"use asm"</code> directive specified
by asm.js is ignored by Duktape.  Also, because there is not typed array
support yet, no "heap object" can be provided.</p><h2 class="sectiontitle" id="compatibility-emscripten">Emscripten <a class="sectionlink" href="#compatibility-emscripten">§</a></h2><p><a href="https://github.com/kripken/emscripten">Emscripten</a> compiles
C/C++ into Javascript.  Duktape is currently Emscripten compatible except
for:</p><ul>
<li>Duktape doesn't yet have typed arrays, so give <code>emcc</code> the
    option <code>-s USE_TYPED_ARRAYS=0</code> to disable their use.</li>
</ul><p>Performance is somewhat limited as Duktape is an interpreted engine.
Lack of typed array support also forces Emscripten to use a much slower model
for emulating application memory.  Large programs may fail due to Duktape
compiler running out of virtual registers.  See 
<a href="https://github.com/svaarala/duktape/blob/master/doc/emscripten-status.rst">emscripten-status.rst</a>
for current compatibility status.</p><p>Duktape itself compiles with Emscripten, and it is possible to run Duktape inside
a web page for instance, see
<a href="dukweb.html">Dukweb REPL</a>.</p><h2 class="sectiontitle" id="compatibility-luajs">Lua.js <a class="sectionlink" href="#compatibility-luajs">§</a></h2><p><a href="https://github.com/mherkender/lua.js">lua.js</a> translates Lua
code to Javascript.  There are no known issues in running the generated
Javascript, except that Duktape doesn't provide <code>console.log</code>
which lua.js expects.  This is easy to remedy, e.g. by prepending the
following:</p><pre class="ecmascript-code"><span class="normal">console </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> log</span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="normal">Array</span><span class="symbol">.</span><span class="keyword">prototype</span><span class="symbol">.</span><span class="normal">join</span><span class="symbol">.</span><span class="function">call</span><span class="symbol">(</span><span class="normal">arguments</span><span class="symbol">,</span><span class="normal"> </span><span class="string">' '</span><span class="symbol">));</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
</pre><h2 class="sectiontitle" id="compatibility-jsinterpreter">JS-Interpreter <a class="sectionlink" href="#compatibility-jsinterpreter">§</a></h2><p><a href="https://github.com/NeilFraser/JS-Interpreter">JS-Interpreter</a>
interprets Javascript in Javascript.  JS-Interpreter works with Duktape,
except that Duktape doesn't provide <code>window</code> which JS-Interpreter
expects.  This can be fixed by prepending:</p><pre class="ecmascript-code"><span class="normal">window </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{}</span><span class="symbol">;</span>
</pre><hr/><h1 class="sectiontitle" id="versioning">Versioning <a class="sectionlink" href="#versioning">§</a></h1><h2 class="sectiontitle" id="semantic-versioning">Semantic versioning <a class="sectionlink" href="#semantic-versioning">§</a></h2><p>Duktape follows <a href="http://semver.org/">Semantic Versioning</a>:</p><ul>
<li>Major version changes when API incompatible changes are made.</li>
<li>Minor version changes when backwards-compatible functional changes are made.</li>
<li>Patch version changes when backwards-compatible bug fixes are made.</li>
</ul><p>The "public API" to which these rules apply include:</p><ul>
<li>The Duktape API calls documented on duktape.org, except those tagged
    <code>experimental</code>.  API calls implemented as macros are part of
    the public API, but any internal calls the macros make are not.  Changing
    an API call from a function call to a macro (or vice versa) is considered
    a compatible change.</li>
<li>The global environment visible to Ecmascript code, including the <code>Duktape</code>
    object and other Ecmascript extensions, as documented on duktape.org.</li>
</ul><p>The following are not part of the "public API":</p><ul>
<li>Duktape API calls tagged <code>experimental</code>.</li>
<li>Feature options.  Incompatible feature option changes are not made in patch
    releases, but can be made in minor releases (contrary to semantic versioning
    guarantees). Such changes are noted in release notes, and the goal is to cause
    a compile error when a no-longer-supported feature option is used so that any
    incorrect assumptions can be fixed.</li>
<li>Extras distributed with Duktape (<code>extras/</code> directory).</li>
</ul><h2 class="sectiontitle" id="experimental-features">Experimental features <a class="sectionlink" href="#experimental-features">§</a></h2><p>Some new features and API calls are marked <b>experimental</b> which means
that they may change in an incompatible way even in a minor release.</p><p>Features may be marked experimental e.g. because they are useful but
incomplete, or because the best design is not obvious and it's useful to
gather some feedback before committing to the design.  Typically a feature
is experimental for one minor release and then, after the necessary changes,
becomes a fully supported feature.</p><h2 class="sectiontitle" id="version-naming">Version naming <a class="sectionlink" href="#version-naming">§</a></h2><p>Releases use the form <i>(major).(minor).(patch)</i>, e.g. <b>1.0.3</b>.</p><p>Development pre-releases use the form <i>(major).(minor).(patch)-alpha.(number)</i>,
e.g. <b>1.3.0-alpha.2</b>.  The form <i>0.(minor).0</i> was used for development
pre-releases before the 1.0 release.</p><h2 class="sectiontitle" id="versioning.4">DUK_VERSION and Duktape.version <a class="sectionlink" href="#versioning.4">§</a></h2><p><code>DUK_VERSION</code> and <code>Duktape.version</code> provide version
identification using a single number computed as:
<code>(major * 10000 + minor * 100 + patch)</code>,
then subtracting one for development pre-releases.</p><p>Note the limitations for development pre-releases:</p><ul>
<li>Development pre-releases for the same release are not distinguished from
    one another: for example, both 1.3.0-alpha.1 and 1.3.0-alpha.2 are
    identified as 10299.</li>
<li>Development pre-releases for patch releases are not distinguished from the
    previous patch release: for example, 1.3.3-alpha.6 and 1.3.2 are both
    identified as 10302.</li>
</ul><p>Development pre-releases shouldn't be used in production, but the current
<code>DUK_VERSION</code> and <code>Duktape.version</code> number provides
a useful approximation for version comparison: an alpha release will compare
smaller than the actual release, but higher (or equal) than a previous release.</p><h2 class="sectiontitle" id="versioning-examples">Examples <a class="sectionlink" href="#versioning-examples">§</a></h2><p>The table below provides some examples, in ascending version order:</p><table>
<tr>
<th>Version</th>
<th>Pre-release?</th>
<th>DUK_VERSION &amp;<br/>Duktape.version</th>
<th>Notes</th>
</tr>
<tr><td>0.12.0</td><td>yes</td><td>1200</td><td>Pre-release before 1.0 release.</td></tr>
<tr><td>1.0.0</td><td>no</td><td>10000</td><td></td></tr>
<tr><td>1.3.0-alpha.1</td><td>yes</td><td>10299</td><td>Identified like 1.2.99, first 1.3.0 development pre-release.</td></tr>
<tr><td>1.3.0-alpha.2</td><td>yes</td><td>10299</td><td>Identified like 1.2.99, no difference to 1.3.0-alpha.1.</td></tr>
<tr><td>1.3.0</td><td>no</td><td>10300</td><td></td></tr>
<tr><td>1.3.2</td><td>no</td><td>10302</td><td></td></tr>
<tr><td>1.3.3-alpha.6</td><td>yes</td><td>10302</td><td>Identified like 1.3.2, no difference to 1.3.2 release.</td></tr>
<tr><td>1.3.3</td><td>no</td><td>10303</td><td></td></tr>
<tr><td>2.0.0-alpha.3</td><td>yes</td><td>19999</td><td>Identified like 1.99.99.</td></tr>
<tr><td>2.0.0</td><td>no</td><td>20000</td><td></td></tr>
</table><h2 class="sectiontitle" id="version-maintenance">Maintenance of stable versions <a class="sectionlink" href="#version-maintenance">§</a></h2><p>There's no long term maintenance policy yet: stable versions will get bug
fixes (patch releases) at least until the next stable version has been
released, and there has been some time to migrate to it.</p><h2 class="sectiontitle" id="versioning.7">Incompatible changes <a class="sectionlink" href="#versioning.7">§</a></h2><p>The general goal for incompatible changes is that an application relying
on old, unsupported features will fail to build.  It is preferable to have the
build fail rather than to be silently broken.  This means for example that:</p><ul>
<li>When API call semantics are changed, the old API call is removed (causing
    a build failure if used) and a new one is added.</li>
<li>When support for an old feature option is removed, an attempt to use it
    will cause a build failure.</li>
</ul><p>This is not a hard rule, but the default guideline.</p><hr/><h1 class="sectiontitle" id="limitations">Limitations <a class="sectionlink" href="#limitations">§</a></h1><p>The following is a list of known limitations of the current implementation.
Limitations include shortcomings from a semantics perspective, performance
limitations, and implementation limits (which are inevitable).</p><p>Trivial bugs are not listed unless they are "long term bugs".</p><h2 class="sectiontitle" id="limitations.1">No re-entrancy <a class="sectionlink" href="#limitations.1">§</a></h2><p>A single Duktape heap, i.e. contexts sharing the same garbage collector,
is <b>not re-entrant</b>.  Only one C/C++ thread can call Duktape APIs
at a time for a particular Duktape heap (although the calling thread
can change over time).  See <a href="#threading">Threading</a>.</p><h2 class="sectiontitle" id="limitations.2">String and buffer limits <a class="sectionlink" href="#limitations.2">§</a></h2><p>The internal representation allows a maximum length of 2**31-1 (0x7fffffff)
<i>bytes</i> (not characters) for strings.  16-bit codepoints encode into 3
bytes of UTF-8 in the worst case, so the maximum string length which is
guaranteed to work is about 0.7G characters.</p><p>Buffer values are also limited to 2**31-1 (0x7fffffff) bytes.</p><h2 class="sectiontitle" id="limitations.3">Property limits <a class="sectionlink" href="#limitations.3">§</a></h2><p>An object can have at most <code>DUK_HOBJECT_MAX_PROPERTIES</code> (an
internal define).  Currently this limit is 0x7ffffffff.</p><h2 class="sectiontitle" id="limitations.4">Array limits <a class="sectionlink" href="#limitations.4">§</a></h2><p>When array item indices go over the 2**31-1 limit (0x7fffffff), Duktape
has some known bugs with array semantics.</p><h2 class="sectiontitle" id="limitations.5">Regexp quantifier over empty match <a class="sectionlink" href="#limitations.5">§</a></h2><p>The regexp engine gets stuck when a quantifier is used over an
empty match but eventually bails out with an internal recursion
(or execution step) limit.  For instance, the following should produce
a "no match" result but hits an internal recursion limit instead:</p><pre>
$ duk
duk&gt; t = /(x*)*/.exec('y');
RangeError: regexp executor recursion limit
        duk_regexp_executor.c:145
        exec (null) native strict preventsyield
        global input:1 preventsyield
</pre><h2 class="sectiontitle" id="limitations.6">Duktape does not fully support locales <a class="sectionlink" href="#limitations.6">§</a></h2><p>Although Duktape supports the concept of a local time, it doesn't support
other locale related features such as: locale specific Date formatting,
locale specific string comparison, locale/language specific Unicode rules
(such as case conversion rules for Turkish, Azeri, and Lithuanian).</p><h2 class="sectiontitle" id="limitations.7">Unicode case conversion is not locale or context sensitive <a class="sectionlink" href="#limitations.7">§</a></h2><p>E5 Sections 15.5.4.16 to 15.5.4.19 require context and locale processing
of Unicode <code>SpecialCasing.txt</code>.  However, Duktape doesn't currently
have a notion of "current locale".</p><h2 class="sectiontitle" id="limitations.8">Array performance when using non-default property attributes <a class="sectionlink" href="#limitations.8">§</a></h2><p>All array elements are expected to be writable, enumerable, and configurable
(default property attributes for new properties).  If this assumption is violated,
even temporarily, the entire "array part" of an object is abandoned permanently
and array entries are moved to the "entry part".  This involves interning all used
array indices as explicit string keys (e.g. "0", "1", etc).  This is not a
compliance concern, but degrades performance.</p><h2 class="sectiontitle" id="limitations.9">Array performance when writing elements using Object.defineProperty() <a class="sectionlink" href="#limitations.9">§</a></h2><p>When number indexed array elements are written with <code>Object.defineProperty()</code>
the current implementation abandons the internal "array part" which makes later
array access much slower.  Write array elements with direct assignments such as
<code>a[123] = 321</code> to avoid this.</p><h2 class="sectiontitle" id="limitations.10">Global/eval code is slower than function code <a class="sectionlink" href="#limitations.10">§</a></h2><p>Bytecode generated for global and eval code cannot assign variables
statically to registers, and will use explicit name-based variable
read/write accesses.  Bytecode generated for function code doesn't
have this limitation; most variables are assigned statically to registers
and direct register references are used used to access them.</p><p>This is a minor issue unless you spend a lot of time running top-level
global/eval code.  The workaround is simple: put code in a function which
you call from the top level; for instance:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">main</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// ...</span>
<span class="cbracket">}</span>
<span class="function">main</span><span class="symbol">();</span>
</pre><p>There is also a common idiom of using an anonymous function for this
purpose:</p><pre class="ecmascript-code"><span class="symbol">(</span><span class="keyword">function</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// ...</span>
<span class="cbracket">}</span><span class="symbol">)();</span>
</pre><h2 class="sectiontitle" id="limitations.11">Function temporaries may be live for garbage collection longer than expected <a class="sectionlink" href="#limitations.11">§</a></h2><p>Ecmascript functions are compiled into bytecode with a fixed set of
registers.  Some registers are reserved for arguments and variable
bindings while others are used as temporaries.  All registers are
considered live from a garbage collection perspective, even temporary
registers containing old values which the function actually cannot
reference any more.  Such temporaries are considered reachable until they
are overwritten by the evaluation of another expression or until the
function exits.  Function exit is the only easily predicted condition to
ensure garbage collection.</p><p>If you have a function which remains running for a very long time, it
should contain the bare minimum of variables and temporaries that could
remain live.  For instance, you can structure code like:</p><pre class="ecmascript-code"><span class="keyword">function</span><span class="normal"> </span><span class="function">runOnce</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// run one iteration, lots of temporaries</span>
<span class="cbracket">}</span>

<span class="keyword">function</span><span class="normal"> </span><span class="function">foreverLoop</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">runOnce</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span>
</pre><p>This is typically not an issue if there are no long-running functions.</p><h2 class="sectiontitle" id="limitations.12">Function instances are garbage collected only by mark-and-sweep <a class="sectionlink" href="#limitations.12">§</a></h2><p>Every Ecmascript function instance is, by default, in a reference loop with
an automatic prototype object created for the function.  The function instance's
<code>prototype</code> property points to the prototype object, and the prototype's
<code>constructor</code> property points back to the function instance.  Only
mark-and-sweep is able to collect these reference loops at the moment.  If you
build with reference counting only, function instances may appear to leak memory;
the memory will be released when the relevant heap is destroyed.</p><p>You can break the reference loops manually (although this is a bit cumbersome):</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> f </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> g </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="keyword">var</span><span class="normal"> h </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">f</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="string">'finalizer for f'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">g</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="string">'finalizer for g'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">fin</span><span class="symbol">(</span><span class="normal">h</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">function</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="string">'finalizer for h'</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">);</span>

<span class="comment">// not collected until heap destruction in a reference counting only build</span>
<span class="normal">f </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// not collected immediately</span>

<span class="comment">// break cycle by deleting 'prototype' reference (alternative 1)</span>
<span class="normal">g</span><span class="symbol">.</span><span class="keyword">prototype</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span>
<span class="normal">g </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// collected immediately, finalizer runs</span>

<span class="comment">// break cycle by deleting 'constructor' reference (alternative 2)</span>
<span class="normal">h</span><span class="symbol">.</span><span class="keyword">prototype</span><span class="symbol">.</span><span class="normal">constructor </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span>
<span class="normal">h </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">null</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// collected immediately, finalizer runs</span>

<span class="comment">// no-op with refcount only, with mark-and-sweep finalizer for 'f' runs</span>
<span class="normal">Duktape</span><span class="symbol">.</span><span class="function">gc</span><span class="symbol">();</span>
</pre><p>For internal technical reasons, named function expressions are also in a
reference loop with an internal environment record object.  This loop cannot
be broken from user code and only mark-and-sweep can collect such functions.
Ordinary function declarations and anonymous functions don't have this
limitation.  Example:</p><pre class="ecmascript-code"><span class="keyword">var</span><span class="normal"> fn </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">function</span><span class="normal"> </span><span class="function">myfunc</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// myfunc is in reference loop with an internal environment record,</span>
<span class="normal">    </span><span class="comment">// and can only be collected with mark-and-sweep.</span>
<span class="cbracket">}</span>
</pre><p>These issues can be avoided by compiling Duktape with mark-and-sweep
enabled (which is the default).</p><h2 class="sectiontitle" id="limitations.13">Non-standard function 'caller' property limitations <a class="sectionlink" href="#limitations.13">§</a></h2><p>When <code>DUK_OPT_NONSTD_FUNC_CALLER_PROPERTY</code> is given, Duktape
updates the <code>caller</code> property of non-strict function instances
similarly to e.g. V8 and
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller">Spidermonkey</a>.
There are a few limitations, though:</p><ul>
<li>When a (non-strict) function is called from eval code, Duktape sets
    <code>caller</code> to <code>null</code> if the eval code is non-strict,
    and <code>eval</code> (reference to the eval built-in function) if the
    eval code is strict.  This deviates from e.g. V8 behavior.</li>
<li>Coroutines and <code>caller</code> don't mix well: <code>caller</code>
    may be left in a non-<code>null</code> state even after coroutine call
    stacks have been fully unwound.  Also, if a coroutine is garbage collected
    before its call stack is unwound, the <code>caller</code> property of
    functions in its call stack will not get updated now.</li>
</ul><p>See the internal <code>test-bi-function-nonstd-caller-prop.js</code> test
case for further details.</p><hr/><h1 class="sectiontitle" id="comparisontolua">Comparison to Lua <a class="sectionlink" href="#comparisontolua">§</a></h1><p>Duktape borrows a lot from Lua conceptually.  Below are a few notes on
what's different in Duktape compared to Lua.  This may be useful if you're
already familiar with Lua.</p><h2 class="sectiontitle" id="comparisontolua.1">Array and stack indices are zero-based <a class="sectionlink" href="#comparisontolua.1">§</a></h2><p>All array and stack indices are zero-based, not one-based as in Lua.  So,
bottom of stack is 0, second element from bottom is 1, and top element is -1.
Because 0 is no longer available to denote an invalid/non-existent element,
the constant <code>DUK_INVALID_INDEX</code> is used instead in Duktape.</p><p>String indices are also zero-based, and slices are indicated with an
inclusive start index and an exclusive end index (i.e. [start,end[).
In Lua, slices are indicated with inclusive indices (i.e. [start,end]).</p><h2 class="sectiontitle" id="comparisontolua.2">Object type represents functions and threads <a class="sectionlink" href="#comparisontolua.2">§</a></h2><p>In Lua functions and threads are a separate type from objects.
In Duktape the object type is used for plain objects, Ecmascript and
native functions, and threads (coroutines).  As a result, all of these
have a mutable and extensible set of properties.</p><h2 class="sectiontitle" id="comparisontolua.3">Lua userdata and lightuserdata <a class="sectionlink" href="#comparisontolua.3">§</a></h2><p>The concept closest to Lua <code>userdata</code> is the Duktape <code>buffer</code>
type, with the following differences:</p><ul>
<li>Duktape buffers can be resizable, Lua userdata values cannot.  If a
    Duktape buffer is resizable, its data pointer is no longer guaranteed
    to be stable.</li>
<li>Duktape buffers are raw byte arrays without any properties, Lua userdata
    objects can store an environment reference.</li>
</ul><p>Lua <code>lightuserdata</code> and Duktape <code>pointer</code> are essentially
the same.</p><p>If you need to associate properties with a Duktape buffer, you can use
an actual object and have the buffer as its property.  You can then add a
finalizer to the object to free any resources related to the buffer.  This
works reasonably well as long as nothing else holds a reference to the buffer.
If this were the case, the buffer could get used after the object had already
been finalized.  To safeguard against this, the native C structure should
have a flag indicating whether the data structure is open or closed.  This
is good practice anyway for robust native code.</p><h2 class="sectiontitle" id="comparisontolua.4">Garbage collection <a class="sectionlink" href="#comparisontolua.4">§</a></h2><p>Duktape has a combined reference counting and non-incremental mark-and-sweep
garbage collector (mark-and-sweep is needed only for reference cycles).  Collection
pauses can be avoided by disabling voluntary mark-and-sweep passes
(<code>DUK_OPT_NO_VOLUNTARY_GC</code>).  Lua has an incremental collector with no
pauses, but has no reference counting.</p><p>Duktape has an emergency garbage collector.  Lua 5.2 has an emergency
garbage collector while Lua 5.1 does not (there is an emergency GC patch
though).</p><h2 class="sectiontitle" id="comparisontolua.5">duk_safe_call() vs. lua_cpcall() <a class="sectionlink" href="#comparisontolua.5">§</a></h2><p><code>duk_safe_call()</code> is a protected C function call which
operates in the existing value stack frame.  The function call is
not visible on the call stack all.</p><p><code>lua_cpcall()</code> creates a new stack frame.</p><h2 class="sectiontitle" id="comparisontolua.6">Bytecode use <a class="sectionlink" href="#comparisontolua.6">§</a></h2><p>Duktape Ecmascript function bytecode is currently a purely internal
matter.  Code cannot currently be loaded from an external pre-compiled
bytecode file.  Similarly, there is no equivalent to e.g. <code>lua_dump()</code>.</p><h2 class="sectiontitle" id="comparisontolua.7">Metatables <a class="sectionlink" href="#comparisontolua.7">§</a></h2><p>There is no equivalent of Lua metatables in Ecmascript E5/E5.1, but
<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-objects">Ecmascript E6 Proxy objects</a>
provide similar functionality.  To allow property virtualization better than available in
E5/E5.1, Duktape implements an <a href="#es6-proxy">ES6 Proxy subset</a>.</p><h2 class="sectiontitle" id="comparisontolua.8">lua_next() vs. duk_next() <a class="sectionlink" href="#comparisontolua.8">§</a></h2><p><code>lua_next()</code> replaces the previous key and value with a new pair,
while <code>duk_next()</code> does not; the caller needs to explicitly pop the
key and/or value.</p><h2 class="sectiontitle" id="comparisontolua.9">Raw accessors <a class="sectionlink" href="#comparisontolua.9">§</a></h2><p>There is no equivalent to Lua raw table access functions like
<code>lua_rawget</code>.  One can use the following Ecmascript built-ins
for a similar effect (though not with respect to performance):
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.3">Object.getOwnPropertyDescriptor ( O, P )</a>,
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6">Object.defineProperty ( O, P, Attributes )</a>.</p><h2 class="sectiontitle" id="comparisontolua.10">Coroutines <a class="sectionlink" href="#comparisontolua.10">§</a></h2><p>There are no primitives for coroutine control in the Duktape API
(Lua API has e.g. <code>lua_resume</code>).  Coroutines can only be controlled
using the functions exposed by the <code>Duktape</code> built-in.  Further,
Duktape has quite many coroutine yield restrictions now; for instance,
coroutines cannot yield from inside constructor calls or getter/setter calls.</p><h2 class="sectiontitle" id="comparisontolua.11">Multiple return values <a class="sectionlink" href="#comparisontolua.11">§</a></h2><p>Lua supports multiple return values, Duktape (or Ecmascript) currently
doesn't.  This may change with Ecmascript E6, which has a syntax for
multiple value returns.  The Duktape/C API reserves return values above 1
so that they may be later used for multiple return values.</p><h2 class="sectiontitle" id="comparisontolua.12">Weak references <a class="sectionlink" href="#comparisontolua.12">§</a></h2><p>Lua supports weak references.  Duktape currently doesn't.</p><h2 class="sectiontitle" id="comparisontolua.13">Unicode <a class="sectionlink" href="#comparisontolua.13">§</a></h2><p>Lua has no built-in Unicode support (strings are byte strings), while
Duktape has support for 16-bit Unicode as part of Ecmascript compliance.</p><h2 class="sectiontitle" id="comparisontolua.14">Streaming compilation <a class="sectionlink" href="#comparisontolua.14">§</a></h2><p>Lua has a streaming compilation API which is good when code is read from
the disk or perhaps decompressed on-the-fly.  Duktape currently does not
support streaming compilation because it needs multiple passes over the
source code.</p></div> <!-- site-middle-content -->
</div> <!-- site-middle -->
<div id="site-bottom">
<hr/>
<p>Duktape is (C) by its <a href="https://github.com/svaarala/duktape/blob/master/AUTHORS.rst">authors</a>
and licensed under the <a href="https://github.com/svaarala/duktape/blob/master/LICENSE.txt">MIT license</a>.</p>
</div> <!-- site-bottom -->
</body>
</html>
